from functools import cache
from itertools import accumulate, islice
from more_itertools import difference, flatten
from functools import reduce
from math import factorial, sqrt, lcm, gcd
from fractions import Fraction
import operator
from operator import itemgetter
import time
from pathlib import Path
import requests
import json
from requests import get
from sys import setrecursionlimit, set_int_max_str_digits
from typing import Callable, TypeAlias, Iterator, Dict, Tuple, NamedTuple

setrecursionlimit(3000)
set_int_max_str_digits(5000)


def InvertMatrix(L: list[list[int]], check: bool = True) -> list[list[int]]:
    """
    Calculates the inverse of a lower triangular matrix.
    Args:
        The lower triangular matrix to be inverted.
        Check whether the inverse exists as an integer matrix, default is True.
    Returns:
        The integer inverse of the lower triangular matrix if it exists.
        []: If the inverse does not exist.
    """
    n = len(L)
    inv = [[0 for _ in range(n)] for _ in range(n)]  # Identity matrix
    for i in range(n):
        inv[i][i] = 1
    for k in range(n):
        for j in range(n):
            for i in range(k):
                inv[k][j] -= inv[i][j] * L[k][i]
            if check:
                a = inv[k][j]
                b = L[k][k]
                if b == 0:
                    return []
                a, r = divmod(a, b)  # make sure that a is integer
                if r != 0:
                    return []
    return [row[0 : n + 1] for n, row in enumerate(inv)]


def InvertTriangle(r: Callable[[int], list[int]], dim: int) -> list[list[int]]:
    """
    Inverts a triangular matrix generated by a given function.
    Args:
        r (Callable[[int], list[int]]): A function that takes an integer n and returns a list of integers representing the nth row of a triangular matrix.
        dim (int): The dimension of the triangular matrix.
    Returns:
        The integer inverse of the lower triangular matrix if it exists.
        []: If the inverse does not exist.
    """
    M = [[r(n)[k] for k in range(n + 1)] for n in range(dim)]
    return InvertMatrix(M, True)


"""Type: row"""
trow: TypeAlias = list[int]
"""Type: triangle"""
tabl: TypeAlias = list[list[int]]
"""Type: sequence"""
seq: TypeAlias = Callable[[int], int]
"""Type: row generator"""
rowgen: TypeAlias = Callable[[int], trow]
"""Type: triangle generator"""
tblgen: TypeAlias = Callable[[int, int], int]


class Table:
    """Provides basic methods for manipulating integer triangles."""

    def __init__(
        self,
        gen: rowgen,
        id: str,
        oeis: list[str] = [""],
        invid: str = "",
        tex: str = "",
    ) -> None:
        """
        Provides basic methods for manipulating integer triangles.
        Args:
            gen:  Function gen(n:int) -> list[int], defined for all n >= 0.
            id:   The name of the triangle.
            oeis:  A list of A-numbers of closely related OEIS triangles.
            invid: The identifier for the inverse of the triangle.
            tex: Defining formula as a TeX-string.
        """
        self.gen = gen
        self.id = id
        self.oeis = oeis
        self.invid = invid
        self.tex = tex
        self.invQ = invid != ""

    def __getitem__(self, n: int) -> trow:
        """
        Returns the n-th row of the triangle.
        Args:
            n: The index of the row.
        Returns:
            list[int]: The generated row.
        Raises:
            IndexError: if n < 0.
        """
        if n < 0:
            raise IndexError("0 <= n expected")
        return self.gen(n)

    def row(self, n: int) -> trow:
        """
        Return the n-th row of generated table
        Args:
            n, row index
        Returns:
            trow: The n-th row of the table.
        Raises:
            IndexError: if n < 0.
        """
        if n < 0:
            raise IndexError("0 <= n expected")
        return self.gen(n)

    def __call__(self, n: int, k: int) -> int:
        """
        Return term of table with index (n, k).
        Args:
            n, row index
            k, column index
        Returns:
            term of the table

        Raises:
            IndexError: if k > n, k < 0, or n < 0.
        """
        if k > n or k < 0 or n < 0:
            raise IndexError("0<=k<=n expected")
        return self.row(n)[k]

    def val(self, n: int, k: int) -> int:
        """
        Return the term of the table with index (n, k).
        Args:
            n, row index
            k, column index
        Returns:
            term of the table
        Raises:
            IndexError: if k > n, k < 0, or n < 0.
        """
        if k > n or k < 0 or n < 0:
            raise IndexError("0<=k<=n expected")
        return self.row(n)[k]

    def itr(self, size: int) -> Iterator[list[int]]:
        """
        Generate an iterator that yields a specified number of elements from the table.
        Args:
            size (int): The number of elements to yield.
        Returns:
            Iterator[list[int]]: An iterator that yields lists of integers.

        Example:
            >>> for r in Abel.itr(5): print(r, sum(r))
            [1] 1
            [0, 1] 1
            [0, 2, 1] 3
            [0, 9, 6, 1] 16
            [0, 64, 48, 12, 1] 125
        """
        return islice(iter(self.tab(size)), size)

    def tab(self, size: int) -> tabl:
        """
        Generates a table with the specified number of rows.
        Args:
            size, number of rows of the table to be generated
        Returns:
            A table generated with the specified number of rows.
        Example:
            >>> Abel.tab(5)
            [[1], [0, 1], [0, 2, 1], [0, 9, 6, 1], [0, 64, 48, 12, 1]]
        """
        return [list(self.row(n)) for n in range(size)]

    def mat(self, size: int) -> list[list[int]]:
        """
        Generates a size x size matrix with the table as the lower triangle.
        Args:
            size, number of rows and columns
        Returns:
            size x size matrix with the table as the lower triangle.

        Example:
            >>> Abel.mat(5)
            [[1,  0, 0,  0, 0],
            [0,  1,  0,  0, 0],
            [0,  2,  1,  0, 0],
            [0,  9,  6,  1, 0],
            [0, 64, 48, 12, 1]]
        """
        return [
            [self.row(n)[k] if k <= n else 0 for k in range(size)] for n in range(size)
        ]

    def rev(self, n: int) -> trow:
        """
        Reverses the elements of a specified row.
        Args:
            n index of the row to be reversed
        Returns:
            reversed row

        Example:
            >>> Abel.rev(4)
            [1, 12, 48, 64, 0]
        """
        return list(reversed(self.row(n)))

    def antidiag(self, n: int) -> list[int]:
        """
        Args:
            start index of the antidiagonal
        Returns:
            n-th antidiagonal
        Example:
            >>> [Motzkin.antidiag(n) for n in range(5)]
            [[1], [1], [2, 1], [4, 2], [9, 5, 1]]
            A106489
        """
        return [self.row(n - k)[k] for k in range((n + 2) // 2)]

    def alt(self, n: int) -> trow:
        """
        Generate an alternating sequence of terms.
        Args:
            n (int): The index of the row to be generated.
        Returns:
            trow: A list of terms with each term multiplied
                  by (-1) raised to its row index.

        Example:
            >>> Abel.alt(4)
            [0, -64, 48, -12, 1]
        """
        return [(-1) ** k * term for k, term in enumerate(self.row(n))]

    def acc(self, n: int) -> trow:
        """
        Args:
            index of row to be accumulated.
        Returns:
            accumulated row

        Example:
            >>> Abel.acc(4)
            [0, 64, 112, 124, 125]
        """
        return list(accumulate(self.row(n)))

    def diff(self, n: int) -> trow:
        """
        Args:
            index of row the first differences is looked for
        Returns:
            first differences of row

        Example:
            >>> Abel.diff(4)
            [0, 64, -16, -36, -11]
            >>> list(accumulate(Abel.diff(5))) == Abel.row(5)
            True
        """
        return list(difference(self.row(n)))

    def der(self, n: int) -> trow:
        """
        Args:
            index of row-polynomial the derivative is looked for
        Returns:
            derivative of row-polynomial

        Example:
            >>> Abel.der(4)
            [64, 96, 36, 4]
        """
        if n == 0:
            return [0]
        powers = range(n + 1)
        coeffs = self.row(n)
        return list(map(operator.mul, coeffs, powers))[1 : n + 1]

    def diag(self, n: int, size: int) -> list[int]:
        """
        Args:
            n is the start index of the diagonal
            size, length of diagonal
        Returns:
            n-th diagonal starting at the left side

        Example:
            >>> Abel.diag(1, 5)
            [0, 2, 6, 12, 20]
        """
        return [self.row(n + k)[k] for k in range(size)]

    def col(self, k: int, size: int) -> list[int]:
        """
        Args:
            k, start at column k
            size, length of column
        Returns:
            k-th column starting at the main diagonal

        Example:
            >>> Abel.col(1, 5)
            [1, 2, 9, 64, 625]
        """
        return [self.row(k + n)[k] for n in range(size)]

    def sum(self, n: int) -> int:
        """
        Sums up the elements of a specified row.
        Args:
            n index (0-based) of the row to be summed up
        Returns:
            Sum of the elements in the specified row.
        Example:
            >>> Abel.sum(4)
            125
        """
        return sum(self.row(n))

    def flat(self, size: int) -> list[int]:
        """
        Flattens the table by reading the first size rows.
        Args:
            size, number of rows to be flattened
        Returns:
            generated table read by rows, flattened
        Example:
            >>> Abel.flat(5)
            [1, 0, 1, 0, 2, 1, 0, 9, 6, 1, 0, 64, 48, 12, 1]
        """
        return [self.row(n)[k] for n in range(size) for k in range(n + 1)]

    def inv(self, size: int) -> tabl:
        """
        Args:
            size, number of rows of the table to be inverted
        Returns:
            inverse table if it exists, otherwise the empty table
        Example:
            >>> Abel.inv(4)
            [[1], [0, 1], [0, -2, 1], [0, 3, -6, 1]]
        """
        if not self.invQ:
            return []
        M = [[self.row(n)[k] for k in range(n + 1)] for n in range(size)]
        V = InvertMatrix(M)
        if V == []:
            self.invQ = False
            return []
        return V

    def revinv(self, size: int) -> tabl:
        """
        Args:
            size, number of reversed rows of the inverted table
        Returns:
            table with reversed rows of the inverse table if it exists, otherwise the empty table

        Example:
            >>> Abel.revinv(4)
            [[1], [1, 0], [1, -2, 0], [1, -6, 3, 0]]
        """
        V = self.inv(size)
        if V == []:
            return []
        return [[V[n][n - k] for k in range(n + 1)] for n in range(size)]

    def invrev(self, size: int) -> tabl:
        """
        Args:
            size, number of rows of the inverse table of reversed rows
        Returns:
            inverse table of reversed rows if it exists, otherwise the empty table

        Example:
            >>> Abel.invrev(4)
            []
        """
        M = [list(reversed(self.row(n))) for n in range(size)]
        return InvertMatrix(M)

    def off(self, N: int, K: int) -> rowgen:
        """
        Subtriangle based in (N, K).
        Args:
            N, shifts row-offset by N
            K, shifts column-offset by K
        Returns:
            row generator of shifted table

        Example:
            >>> [Abel.off(1, 1)(n) for n in range(4)]
            [[1], [2, 1], [9, 6, 1], [64, 48, 12, 1]]
        """

        def subgen(n: int) -> trow:
            return self.row(n + N)[K : N + n + 1]

        return subgen

    def rev11(self, n: int) -> trow:
        """
        Args:
            size, number of rows
        Returns:
            sub-table with offset (1,1) and reversed rows

        Example:
            >>> [Abel.rev11(n) for n in range(4)]
            [[1], [1, 2], [1, 6, 9], [1, 12, 48, 64]]
        """
        return list(reversed(self.off(1, 1)(n)))

    def inv11(self, size: int) -> tabl:
        """
        Args:
            size, number of rows
        Returns:
            inverse of the sub-table with offset (1,1) if it exists, otherwise the empty table

        Example:
            >>> Abel.inv11(4)
            [[1], [-2, 1], [3, -6, 1], [-4, 24, -12, 1]]
        """
        M = [list(self.off(1, 1)(n)) for n in range(size)]
        return InvertMatrix(M)

    def revinv11(self, size: int) -> tabl:
        """
        Args:
            size, number of rows
        Returns:
            reversed rows of the inverse sub-table with offset (1,1)

        Example:
            >>> Abel.revinv11(4)
            [[1], [1, -2], [1, -6, 3], [1, -12, 24, -4]]
        """
        M = self.inv11(size)
        return [list(reversed(row)) for row in M]

    def invrev11(self, size: int) -> tabl:
        """
        Args:
            size, number of rows
        Returns:
            sub-table with offset (1,1), reversed rows and inverted if it exists, otherwise the empty table
        Example:
            >>> Abel.invrev11(4)
            []
        """
        M = [list(reversed(self.off(1, 1)(n))) for n in range(size)]
        return InvertMatrix(M)

    def poly(self, n: int, x: int) -> int:
        """The rows seen as the coefficients of a polynomial in
        ascending order of powers. Evaluats the n-th row at x.
        Args:
            n, index of row
            x, argument of the polynomial
        Returns:
            sum(T(n, k) * x^j for j=0..n)

        Example:
            >>> Abel.poly(4, 2)
            432
        """
        return sum(c * (x**j) for (j, c) in enumerate(self.row(n)))

    def trans(self, s: seq, size: int) -> list[int]:
        """
        Also called sumprod:
        [sum(T(n, k) * s(k) for 0 <= k <= n) for 0 <= n < size]
        For example, if T is the binomial then this is the
        'binomial transform'.
        Args:
            s, sequence. Recommended to be a cached function.
            size, length of the returned list
        Returns:
            Initial segment of length size of s transformed.
        Example:
            >>> Abel.trans(lambda n: n, 6)
            [0, 1, 4, 24, 200, 2160]
        """
        return [sum(self.row(n)[k] * s(k) for k in range(n + 1)) for n in range(size)]

    def invtrans(self, s: seq, size: int) -> list[int]:
        """
        Also called inverse sumprod:
        [sum((-1)^(n-k) * T(n, k) * s(k) for 0 <= k <= n) for 0 <= n < size]
        For example, if T is the binomial then this is the
        'inverse binomial transform'.
        Args:
            s, sequence. Recommended to be cached function.
            size, length of the returned list
        Returns:
            Initial segment of length size of s transformed.
        Example:
            >>> Abel.invtrans(lambda n*n: n, 6)
            [0, 1, 2, -6, 36, -320]
        """
        return [
            sum((-1) ** (n - k) * self.row(n)[k] * s(k) for k in range(n + 1))
            for n in range(size)
        ]

    def show(self, size: int, total: bool = False) -> None:
        """
        Prints the first 'size' rows with the row-index in front and,
        optionally, the row sum at the end.
        Args:
            size: number of rows to print.
            total (optional): If True, print also the row sum. Defaults to False.

        Example:
            >>> Abel.show(5, True)
            [0] [1] [1]
            [1] [0, 1] [1]
            [2] [0, 2, 1] [3]
            [3] [0, 9, 6, 1] [16]
            [4] [0, 64, 48, 12, 1] [125]
        """
        for n in range(size):
            r = self.row(n)
            print([n], r, [sum(r)] if total else "")


def RevTable(T: Table) -> Table:
    """
    Create a new Table with reversed rows from the given Table.
    Args:
        T (Table): The original Table to reverse.
    Returns:
        Table: A new Table with rows in reverse order.
        The returned Table will have an identifier that appends ":Rev"
        to the original table's identifier.
    """

    @cache
    def revgen(n: int) -> trow:
        return T.rev(n)

    return Table(revgen, T.id + ":Rev")


def AltTable(T: Table) -> Table:
    """
    Creates a new table with terms with alternating signs from the given Table.
    Args:
        T (Table): The original table to generate an alternating form.
    Returns:
        Table: A new table with a generation function of alternating terms.
        The returned Table will have an identifier that appends ":Alt"
        to the original table's identifier.
    """

    @cache
    def altblgen(n: int) -> trow:
        return T.alt(n)

    return Table(altblgen, T.id + ":Alt")


def SubTable(T: Table, N: int, K: int) -> Table:
    """
    Generates a sub-triangle of a given size from a given triangle.
    Args:
        T (Table)
        N (int): The starting row index of the sub-triangle.
        K (int): The starting column index of the sub-triangle.
        size (int): The size of the sub-triangle.
    Returns:
        tabl: The generated sub-triangle.
    """
    return Table(T.off(N, K), T.id + ":Off")


"""Type: trait"""
Trait: TypeAlias = Callable[[Table, int], list[int]]


def fnv(data: bytes) -> int:
    """
    This function calculates the FNV-1a hash value for the given data.
    Args:
        data (bytes): The input data to be hashed.
    Returns:
        int: The calculated hash value.
    """
    assert isinstance(data, bytes)
    hval = 0xCBF29CE484222325
    for byte in data:
        hval ^= byte
        hval *= 0x100000001B3
        hval &= 0xFFFFFFFFFFFFFFFF
    return hval


def FNVhash(seq: str) -> str:
    """Returns the fnv-hash of a string (representing an integer sequence).
    Args:
        seq (list[int]):
    Returns:
        str: The hex value of the hash without the '0x'-head.
    """
    return hex(fnv(bytes(seq, encoding="ascii")))[2:]


def SeqToString(
    seq: list[int],
    maxchars: int,
    maxterms: int,
    sep: str = " ",
    offset: int = 0,
    absval: bool = False,
) -> str:
    """
    Converts a sequence of integers into a string representation.
    Args:
        seq: The sequence of integers to be converted.
        maxchars: The maximum length of the resulting string.
        maxterms: The maximum number of terms included.
        sep: String seperator. Default is ' '.
        offset: The starting index of the sequence. Defaults to 0.
        absval: Use the absolute value of the terms. Defaults to False.
    Returns:
        str: The string representation of the sequence.
    """
    seqstr = ""
    maxt = maxl = 0
    for trm in seq[offset:]:
        maxt += 1
        if maxt > maxterms:
            break
        if absval:
            s = str(abs(trm)) + sep
        else:
            s = str(trm) + sep
        maxl += len(s)
        if maxl > maxchars:
            break
        seqstr += s
    return seqstr


class StopWatch:
    """
    A simple stopwatch utility class to measure elapsed time.
    Attributes:
        start_time (float or None): The start time of the stopwatch.
        text (str): The comment text to display with the elapsed time.
    Methods:
        start() -> None:
            Start the stopwatch. Raises a RuntimeError if the stopwatch
            is already running.
        stop() -> float:
            Stop the stopwatch and report the elapsed time.
            Raises a RuntimeError if the stopwatch is not running.
    """

    def __init__(self, comment: str = "Elapsed time: ") -> None:
        self.start_time = None
        self.text = comment

    def start(self) -> None:
        """Start a new StopWatch"""
        if self.start_time is not None:
            raise RuntimeError("Watch is running. First stop it.")
        self.start_time = time.perf_counter()

    def stop(self) -> float:
        """Stop the StopWatch, and report the elapsed time."""
        if self.start_time is None:
            raise RuntimeError("Watch is not running.")
        elapsed_time = time.perf_counter() - self.start_time
        self.start_time = None
        print(self.text.rjust(17), "{:0.4f}".format(elapsed_time), "sec")
        return elapsed_time


def TableGenerationTime(tabl: Table, size: int = 100) -> None:
    """
    Measures and prints the time taken to generate the table of the given triangle.
    Args:
        tabl (Table): The triangle whose generating will be timed.
        size (int, optional): The size of the table (number of rows). Defaults to 100.
    Returns:
        None
    """
    t = StopWatch(tabl.id)
    t.start()
    tabl.tab(size)
    t.stop()


def TimeIncrease(
    T: Callable[[int, int], int], offset: int = 4, size: int = 5
) -> list[float]:
    """Computes the relative increase of time generating a triangle when the number of rows doubles.
    Args:
        T(n, k): function defined for n >= 0 and 0 <= k <= n.
        offset > 0: the power of two where the test starts. Defaults to 4.
        size: the length of test run. Defaults to 5.
    Returns:
        List of quotients of elapsed time when the number of rows of the triangle doubles.
    Example:
        TimeIncrease(lambda n, k: n**k)
    """
    B: list[float] = []
    for s in [2 << n for n in range(offset - 1, offset + size)]:
        t = StopWatch(str(s))
        t.start()
        [[T(n, k) for k in range(n + 1)] for n in range(s)]
        B.append(t.stop())
    return [B[i + 1] / B[i] for i in range(size)]


def SimilarsList() -> list[str]:
    """
    Collects and returns a sorted list of the A-numbers included in the list
    of 'similars' for all tables in TablesList. The collected A-numbers are
    then sorted and returned as a list (of strings).
    Returns:
        list[str]: A sorted list of A-numbers.
    """
    bag: list[str] = []
    for tab in TablesList:
        for anum in tab.oeis:
            bag.append(anum)
    return sorted(bag)


def IsSimilarTriangleInLib(anum: str) -> bool:
    """Is a triangle similar to the A-number referenced in this library?
    Args:
        A-number as string.
    Returns:
        If 'True' a similar triangle is probably implemented.
    """
    return anum in SimilarsList()


def TablesListPreview(prompt: bool = False) -> None:
    """
    Displays a short view of the tables in the TablesList.
    Args:
        prompt (bool): If True, prompts the user to hit Return/Enter
        after displaying each table. Default is False.
    """
    for T in TablesList:
        print(T.id, T.oeis)
        T.show(6)
        if prompt:
            input("Hit Return/Enter > ")


def MeasureTableGenerationTime(BenchLength: int = 100) -> None:
    t = StopWatch("Full Benchmark")
    t.start()
    for tabl in TablesList:
        TableGenerationTime(tabl, BenchLength)  # type: ignore
    t.stop()


def lcsubstr(s: str, t: str) -> tuple[int, int]:
    """
    With CC BY-SA 4.0 from: https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring
    Finds the longest common substring of s and t that is contiguous.
    Args:
      s: The first string.
      t: The second string.
    Returns:
        (s, l): The matched substring starts at index 's' in the first string and has length 'l'.
    """
    m = [[0] * (1 + len(t)) for _ in range(1 + len(s))]
    longest, x_longest = 0, 0
    for x in range(1, 1 + len(s)):
        for y in range(1, 1 + len(t)):
            if s[x - 1] == t[y - 1]:
                m[x][y] = m[x - 1][y - 1] + 1
                if m[x][y] > longest:
                    longest = m[x][y]
                    x_longest = x
            else:
                m[x][y] = 0
    # lcs_str =  s[x_longest - longest : x_longest]
    return (x_longest - longest, longest)


def QueryOEIS(
    seqlist: list[int], maxnum: int = 1, info: bool = False, minlen: int = 24
) -> int:
    """
    Query if a given sequence is present in the OEIS. At least 24 terms
    of the sequence must be given. The first three terms and signs are disregard.
    Sequences with huge terms might have to few terms to give reliable results.
    This is a heuristic function, understand it's limited reach.
    Args:
        seqlist: The sequence to search. Must have at least 24 terms.
        maxnum: max number of sequences to be returned. Defaults to 1.
        info: Prints details, otherwise is quiet except for warnings. Defaults to False.

        minlen: At least {minlen} terms are required.
    Returns:
        Returns anum is the A-number of the sequence,
        Returns 0 if the sequence was not found.
        If sl < 5 and dl > 12, then anum probably matches the sequence,
        modulo a couple of first terms and the signs.
    Raises:
        Exception: If the OEIS server cannot be reached after multiple attempts.
        Currently, the function will return -999999 if the OEIS server cannot be reached.
    """
    if len(seqlist) < minlen:
        print(f"Sequence is too short! We require at least {minlen} terms.")
        print("You provided:", seqlist)
        return 0
    if 0 == sum(seqlist[0:36]):
        return 4  # XXXXX dont search for the all zeros sequence
    off = (
        0 if 0 == sum(seqlist[3:36]) else 3
    )  # XXXXX dont skip leading terms if the rest is zero
    seqstr = SeqToString(seqlist, 160, 36, ",", off, True)
    url = f"https://oeis.org/search?q={seqstr}&fmt=json"
    for repeat in range(4):
        time.sleep(0.5)  # give the OEIS server some time to relax
        if info:
            print(f"connecting: [{repeat}]")
        try:
            # jdata: None | list[dict[str, int | str | list[str] ]] = get(url, timeout=30).json()
            jdata = get(url, timeout=30).json()
            if jdata == None:
                if 0 == sum(seqlist[::2]) or 0 == sum(seqlist[1::2]):
                    seqlist = [k for k in seqlist if k != 0]
                    seqstr = SeqToString(seqlist, 160, 36, ",", 3, True)
                    if info:
                        print("Searching without zeros:", seqstr)
                    url = f"https://oeis.org/search?q={seqstr}&fmt=json"
                    raise ValueError("Try again")
                if info:
                    print("Sorry, no match found for:", seqstr)
                return 0
            number = dl = ol = 0
            for j in range(min(maxnum, len(jdata))):
                seq = jdata[j]
                number = seq["number"]
                anumber = f"A{(6 - len(str(number))) * '0' + str(number)}"
                name = seq["name"]
                data = seq["data"].replace("-", "")  # type: ignore
                seqstr = SeqToString(seqlist, 160, 25, ",", 0, True)
                start, length = lcsubstr(data, seqstr)  # type: ignore
                ol = data.count(",")  # type: ignore
                sl = data.count(",", 0, start)  # type: ignore
                dl = data.count(",", start, start + length)  # type: ignore
                if dl < 12:
                    print(f"\n*** WARNING! Only {dl} out of {ol} terms match! ***\n")
                if info or dl < 12:
                    print("You searched:", seqstr)
                    print("OEIS-data is:", data)  # type: ignore
                    print(
                        f"Info: Starting at index {sl} the next {dl} consecutive terms match.\nThe matched substring starts at byte {start} and has length {length}."
                    )
                    print("*** Found:", anumber, name)
                if dl > 12:
                    break
            return int(number)
        except ValueError:
            continue
        except requests.exceptions.RequestException as e:
            print(f"Error: {e}")
    # raise Exception(f"Could not open {url}.")
    print(f"Exception! Could not open {url}.")
    return -999999


def LookUp(t: Table, tr: Trait, info: bool = True) -> int:
    """
    Look up the A-number in the OEIS database based on a trait of a table.
    Args:
        t (Table): The table to be analyzed.
        tr (Trait): A function that extracts a trait from the table.
        info (bool, optional): If True, information about the matching will be displayed. Defaults to True.
    Returns:
        int: The A-number of the sequence if found, otherwise 0.

    Raises:
        Exception: If the OEIS server cannot be reached after multiple attempts.
        Currently, the function will return -999999 if the OEIS server cannot be reached.

    Example:
        >>> LookUp(Fubini, PolyDiag)
        connecting: [0]
        You searched: 1,1,10,219,8676,...
        OEIS-data is: 1,1,10,219,8676,...
        Info: Starting at index 0 the next 13 consecutive terms match.
        The matched substring starts at 0 and has length 135.
        *** Found: A094420 Generalized ordered Bell numbers Bo(n,n).
        Returns the int 94420.
    """
    return QueryOEIS(tr(t, 24), 1, info)


def dotproduct(vec: list[int], tor: list[int]) -> int:
    """
    Calculate the dot product of two vectors.
    Args:
        vec (list[int]): The first vector.
        tor (list[int]): The second vector.
    Returns:
        int: The dot product of the two vectors.
    Raises:
        ValueError: If the input vectors are not of the same length.
    Example:
        >>> dotproduct([1, 2, 3], [4, 5, 6])
        32
    """
    """Returns the dot product of the two vectors."""
    return sum(map(operator.mul, vec, tor))


def Triangle(T: Table, size: int = 7) -> list[int]:
    """
    Generates an integer triangle (a regular lower triangular table) as a list of rows.
    Args:
        T (Table): The table referencing the generating function.
        size (int, optional): The number of rows requested. Defaults to 7.
    Returns:
        list[int]: The rows flattened to a list of integers.

    Example:
        >>> Triangle(Abel, 4)
        [1, 0, 1, 0, 2, 1, 0, 9, 6, 1]
        A137452
    """
    return T.flat(size)


def Trev(T: Table, size: int = 7) -> list[int]:
    """
    Generates an integer triangle by reversing the rows of the given table.
    Args:
        T (Table): The table with the generating function of the original object.
        size (int, optional): The number of rows to reverse. Defaults to 7.
    Returns:
        list[int]: A flattened list of the reversed rows.

    Example:
        >>> Trev(StirlingSet, 4)
        [1, 1, 0, 1, 1, 0, 1, 3, 1, 0]
        A106800
    """
    return list(flatten([T.rev(n) for n in range(size)]))


def Tinv(T: Table, size: int = 7) -> list[int]:
    """
    Inverts the given table (matrix inversion) and flattens the resulting table.
    Args:
        T (Table): The table to be inverted.
        size (int, optional): The desired number of rows. Defaults to 7.
    Returns:
        list[int]: A flattened list of integers representing the inverted table.

    Example:
        >>> Tinv(Abel, 4)
        [1, 0, 1, 0, -2, 1, 0, 3, -6, 1]
        A059297
    """
    return list(flatten(T.inv(size)))


def Tinvrev(T: Table, size: int = 7) -> list[int]:
    """
    First reverse the table and then invert the reversed table.
    Args:
        T (Table): The table to be inverted and reversed.
        size (int, optional): The desired number of rows. Defaults to 7.
    Returns:
        list[int]: A flattened list of integers after reversing and inverting the table.

    Example:
        >>> Tinvrev(FallingFactorial, 4)
        [1, -1, 1, 0, -2, 1, 0, 0, -3, 1]
        A132013
    """
    return list(flatten(T.invrev(size)))


def Trevinv(T: Table, size: int = 7) -> list[int]:
    """
    First invert the table and then revert the rows of the inverted table.
    Args:
        T (Table): The table to be inverted and reversed.
        size (int, optional): The desired number of rows. Defaults to 7.
    Returns:
        list[int]: A flattened table after inverting and reversing the table.

    Example:
        >>> Trevinv(DyckPaths, 4)
        [1, 1, -1, 1, -3, 1, 1, -5, 6, -1]
        A054142
    """
    return list(flatten(T.revinv(size)))


def Toff11(T: Table, size: int = 8) -> list[int]:
    """
    Creates a new Table object offset by 1 row and 1 column from the original table,
    and returns a flattened list of rows of the new table.
    Args:
        T (Table): The original table object.
        size (int, optional): The desired number of rows. Defaults to 8.
    Returns:
        list[int]: A flattened list of rows from the shifted table.

    Example:
        >>> T = Abel
        >>> T11 = Table(T.off(1, 1), T.id + "off11")
        >>> print(T.id); T.show(4);
        >>> print(T11.id); T11.show(4)

        >>> print("Inverse of T:"); print(T.inv(4))
        >>> print("Inverse of T11:"); print(T11.inv(4))
        >>> print(f"PolyRows of {T.id}:")
        >>> for n in range(4): print(PolyRow(T, n, 5))
        >>> print(f"PolyRows of {T11.id}:")
        >>> for n in range(4): print(PolyRow(T11, n, 5))
        Abel
        [0] [1]
        [1] [0, 1]
        [2] [0, 2, 1]
        [3] [0, 9, 6, 1]
        Abeloff11
        [0] [1]
        [1] [2, 1]
        [2] [9, 6, 1]
        [3] [64, 48, 12, 1]
        Inverse of T:
        [[1], [0, 1], [0, -2, 1], [0, 3, -6, 1]]
        Inverse of T11:
        []
        PolyRows of Abel:
        [1, 1, 1, 1, 1]
        [0, 1, 2, 3, 4]
        [0, 3, 8, 15, 24]
        [0, 16, 50, 108, 196]

        PolyRows of Abeloff11:
        [1, 1, 1, 1, 1]
        [2, 3, 4, 5, 6]
        [9, 16, 25, 36, 49]
        [64, 125, 216, 343, 512]
    """
    T11 = Table(T.off(1, 1), T.id + "off11")
    return T11.flat(size)


def Trev11(T: Table, size: int = 8) -> list[int]:
    """
    Generate a flattened list of reversed rows from a Table object with
    offset by 1 row and 1 column.
    Args:
        T (Table): The Table object containing the data.
        size (int, optional): The number of rows to reverse. Defaults to 8.
    Returns:
        list[int]: A flattened list of reversed elements of the shifted table.

    Example:
        >>> Trev11(Eulerian, 4)
        [1, 1, 1, 1, 4, 1, 1, 11, 11, 1]
        A008292

        >>> Trev(Eulerian, 4)
        [1, 1, 0, 1, 1, 0, 1, 4, 1, 0]
        A173018
    """
    return list(flatten([T.rev11(n) for n in range(size)]))


def Tinv11(T: Table, size: int = 8) -> list[int]:
    """
    Compute the inverse of the table with offset 1 row and 1 column
    and flatten the rows of the result.
    Args:
        T (Table): The table object which has the inv11 method.
        size (int, optional): The desired number of rows of the shifted table. Defaults to 8.
    Returns:
        list[int]: A flattened list of integers representing the rows of the shifted table.
    """
    InvT11 = T.inv11(size)
    return list(flatten(InvT11))


def Tinvrev11(T: Table, size: int = 8) -> list[int]:
    """
    First fix the new offset, next reverse and then invert the reversed table.
    Args:
        T (Table): The table object that contains the `invrev11` method.
        size (int, optional): The desired number of rows. Defaults to 8.
    Returns:
        list[int]: A flattened list of the rows of the generated table.

    Example:
        >>> Tinvrev11(Eulerian, 4)
        [1, -1, 1, 3, -4, 1, -23, 33, -11, 1]
        A055325
    """
    InvrevT11 = T.invrev11(size)
    return list(flatten(InvrevT11))


def Trevinv11(T: Table, size: int = 8) -> list[int]:
    """
    First fix the new offset, next inverse and then reverse the rows.
    Args:
        T (Table): The table object to be processed.
        size (int, optional): The desired number of rows. Defaults to 8.
    Returns:
        list[int]: A flattened list of the rows of the generated table.

    Example:
        >>> Trevinv11(Eulerian, 4)
        [1, 1, -1, 1, -4, 3, 1, -11, 33, -23]
    """
    RevinvT11 = T.revinv11(size)
    return list(flatten(RevinvT11))


def Talt(T: Table, size: int = 7) -> list[int]:
    """
    Generate a list of alternative values of the rows of the given table.
    Args:
        T (Table): The Table object from which to generate alternating rows.
        size (int, optional): The desired number of rows. Defaults to 7.
    Returns:
        list[int]: A flattened list of the rows of the generated table.

    Example:
        >>> Talt(Binomial, 4)
        [1, 1, -1, 1, -2, 1, 1, -3, 3, -1]
        A130595
    """
    return list(flatten([T.alt(n) for n in range(size)]))


def Tacc(T: Table, size: int = 7) -> list[int]:
    """
    Accumulate values of the values of the rows of the given table.
    Args:
        T (Table): The table from which to accumulate the row values.
        size (int, optional): The desired number of rows. Defaults to 7.
    Returns:
        list[int]: A flattened list of the rows of the generated table.

    Example:
        >>> Tacc(Binomial, 4)
        [1, 1, 2, 1, 3, 4, 1, 4, 7, 8]
        A008949
    """
    return list(flatten([T.acc(n) for n in range(size)]))


def Tder(T: Table, size: int = 8) -> list[int]:
    """
    Generate a list of rows representing the derivatives of the polynomials interpreting the row values as the coefficients of the polynomials.
    Args:
        T (Table): The Table object to process.
        size (int, optional): The desired number of rows. Defaults to 8.
    Returns:
        list[int]: A flattened list of the rows of the generated table.

    Example:
        >>> Tder(Abel, 5)
        [0, 1, 2, 2, 9, 12, 3, 64, 96, 36, 4]
        A225465
    """
    return list(flatten([T.der(n) for n in range(size)]))


def Tantidiag(T: Table, size: int = 9) -> list[int]:
    """
    Generate the flattened table of the antidiagonals of the given table.
    Args:
        T (Table): The table from which to generate the antidiagonals.
        size (int, optional): The number of antidiagonals. Defaults to 9.
    Returns:
        list[int]: A flattened list of the first `size` antidiagonals of the table.

    Example:
        >>> Tantidiag(Motzkin, 6)
        [1, 1, 2, 1, 4, 2, 9, 5, 1, 21, 12, 3]
        A106489
    """
    return list(flatten([T.antidiag(n) for n in range(size)]))


def TablCol(T: Table, col: int, size: int = 28) -> list[int]:
    """
    Extract a column from the given table and return it as a list of integers.
    Args:
        T (Table): The table from which to extract the column.
        col (int): The index of the column to extract.
        size (int, optional): The number of elements to extract from the column. Defaults to 28.
    Returns:
        list[int]: A list of integers representing the extracted column.
    """
    return [T(col + n, col) for n in range(size)]


def TablCol0(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Retrieve column 0 of a table.
    Args:
        T (Table): The table from which to retrieve the column.
        size (int, optional): The number of elements to retrieve. Defaults to 28.
        rev (bool, optional): If True, retrieve the diagonal instead of the column. Defaults to False.
    Returns:
        list[int]: A list of integers representing the first column or the diagonal of the table.
    """
    if rev:
        return TablDiag0(T, size)
    else:
        return [T(n, 0) for n in range(size)]


def TablCol1(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Retrieve column 1 of a table.
    Args:
        T (Table): The table from which to extract the column.
        size (int, optional): The number of elements in the column. Defaults to 28.
        rev (bool, optional): If True, return the diagonal elements instead of the column. Defaults to False.
    Returns:
        list[int]: A list of integers representing the column or diagonal elements.
    """
    if rev:
        return TablDiag1(T, size)
    else:
        return [T(1 + n, 1) for n in range(size)]


def TablCol2(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Retrieve column 2 of a table.
    Args:
        T (Table): The table from which to extract the column.
        size (int, optional): The size of the list to generate. Defaults to 28.
        rev (bool, optional): If True, generates the list using the TablDiag2 function. Defaults to False.
    Returns:
        list[int]: A list of integers representing column 2
        or diagonal 2 of the given table.
    """
    if rev:
        return TablDiag2(T, size)
    else:
        return [T(2 + n, 2) for n in range(size)]


def TablCol3(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Retrieve column 3 of a table.
    Args:
        T (Table): The table object from which to extract the column.
        size (int, optional): The number of elements to retrieve. Defaults to 28.
        rev (bool, optional): If True, use the TablDiag3 function to generate the list. Defaults to False.
    Returns:
        list[int]: A list of integers generated from the Table object.
    """
    if rev:
        return TablDiag3(T, size)
    else:
        return [T(3 + n, 3) for n in range(size)]


def TablDiag(T: Table, diag: int, size: int = 28) -> list[int]:
    """
    Extracts a diagonal from a table.
    Args:
        T (Table): The table from which to extract the diagonal.
        diag (int): The row index where the diagonal starts.
        size (int, optional): The number of terms of the diagonal. Defaults to 28.
    Returns:
        list[int]: A list of integers representing the diagonal elements.
    """
    return [T(diag + k, k) for k in range(size)]


def TablDiag0(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Generate a list of diagonal elements from a table.
    Args:
        T (Table): The table from which to extract diagonal elements.
        size (int, optional): The number of terms of the diagonal. Defaults to 28.
        rev (bool, optional): If True, extract elements from the first column instead of the diagonal. Defaults to False.
    Returns:
        list[int]: A list of integers representing the diagonal or the first column.
    """
    if rev:
        return TablCol0(T, size)
    else:
        return [T(k, k) for k in range(size)]


def TablDiag1(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Generates the subdiagonal or column 1 of the provided table depending on `rev`.
    Args:
        T (Table): A table function that takes two integer arguments.
        size (int, optional): The number of terms of the diagonal. Defaults to 28.
        rev (bool, optional): A flag to determine which list generation method to use. Defaults to False.
    Returns:
        list[int]: A list of integers representing the subdiagonal or the second column.
    """
    if rev:
        return TablCol1(T, size)
    else:
        return [T(1 + k, k) for k in range(size)]


def TablDiag2(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Generates the diagonal or the column starting at row 2 of the provided table depending on `rev`.
    If `rev` is True, the function returns the result of `TablCol2(T, size)`.
    Otherwise, it returns a list of integers generated by calling the Table
    function `T` with parameters (2 + k, k) for k in the range of `size`.
    Args:
        T (Table): A function that takes two integers and returns an integer.
        size (int, optional): The number of terms of the diagonal. Defaults to 28.
        rev (bool, optional): A flag to determine which list generation method to use. Defaults to False.
    Returns:
        list[int]: A list of integers representing the third diagonal or the third column.
    """
    if rev:
        return TablCol2(T, size)
    else:
        return [T(2 + k, k) for k in range(size)]


def TablDiag3(T: Table, size: int = 28, rev: bool = False) -> list[int]:
    """
    Generates the diagonal or the column starting at row 3 of the provided table depending on `rev`.
    If `rev` is True, the function returns the result of `TablCol3(T, size)`.
    Otherwise, it returns a list of integers generated by calling the Table function `T`
    with parameters (3 + k, k) for k in the range of `size`.
    Args:
        T (Table): A function that takes two integer arguments and returns an integer.
        size (int, optional): The number of terms of the diagonal. Defaults to 28.
        rev (bool, optional): A flag to determine which list to return. Defaults to False.
    Returns:
        list[int]: A list of integers representing the fourth diagonal or the fourth column.
    """
    if rev:
        return TablCol3(T, size)
    else:
        return [T(3 + k, k) for k in range(size)]


def PolyRow(T: Table, row: int, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values for a given row in a table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        row (int): The row index for which to generate polynomial values.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values for the specified row.
    Example:
        >>> print(PolyRow(Abel, 3, 7))
        [0, 16, 50, 108, 196, 320, 486]
    """
    return [T.poly(row, x) for x in range(size)]


def PolyRow1(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values for the first row of a table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values for row 1.
    """
    return [T.poly(1, x) for x in range(size)]


def PolyRow2(T: Table, size: int = 28) -> list[int]:
    """
    Generates a list of polynomial values of row 2 for a given table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values for row 2.
    """
    return [T.poly(2, x) for x in range(size)]


def PolyRow3(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of row 3 for a given table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values for row 3.
    """
    return [T.poly(3, x) for x in range(size)]


def PolyCol(T: Table, col: int, size: int = 28) -> list[int]:
    """
    Generates a list of polynomial values for a specified column in the table generated
    by the polynomials with coefficients from the rows of the given table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        col (int): The column index for which polynomial values are to be generated.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values for the specified column.
    Example:
        >>> print(PolyCol(Abel, 3, 7))
        [1, 3, 15, 108, 1029, 12288, 177147]
        A362354
    """
    return [T.poly(x, col) for x in range(size)]


def PolyCol1(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of degree 1 for a given table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values in column 1.
    """
    return [T.poly(x, 1) for x in range(size)]


def PolyCol2(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of degree 2 for a given table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values in column 2.
    Example:
        >>> PolyCol2(Abel, 7)
        [1, 2, 8, 50, 432, 4802, 65536]
        A007334
    """
    return [T.poly(x, 2) for x in range(size)]


def PolyCol3(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of degree 3 for a given table.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values in column 3.
    """
    return [T.poly(x, 3) for x in range(size)]


def PolyDiag(T: Table, size: int = 28) -> list[int]:
    """
    Generates a list of polynomial diagonal values from a given Table object.
    Args:
        T (Table): The table object containing the polynomial coefficients.
        size (int, optional): The number of diagonal values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial diagonal values.

    Example:
        >>> PolyDiag(Abel, 6)
        [1, 1, 8, 108, 2048, 50000]
        A193678
    """
    return [T.poly(n, n) for n in range(size)]


def RowLcmGcd(g: rowgen, row: int, lg: bool) -> int:
    """
    Calculate the least common multiple (LCM) or greatest common divisor (GCD) of
    non-trivial elements in a row generated by a given row generator function.
    Note our convention to exclude 0 and 1 from the terms.
    Args:
        g (rowgen): A row generator function that takes an integer row index and
                    returns an iterable of integers.
        row (int): The index of the row to process.
        lg (bool): If True, calculate the LCM of the elements; if False, calculate the GCD.
    Returns:
        int: The LCM or GCD of the non-trivial elements in the row. If the row contains
             only trivial elements (-1, 0, 1), returns 1.
    """
    Z = [v for v in g(row) if v not in [-1, 0, 1]]
    if Z == []:
        return 1
    return lcm(*Z) if lg else gcd(*Z)


def TablLcm(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the least common multiple (LCM) for each row in a table.
    Note our convention to exclude 0 and 1 from the terms.
    Args:
        T (Table): The table containing rows for which the LCM is to be calculated.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of LCM values for each row in the table.

    Example:
        >>> TablLcm(Leibniz, 8)
        [1, 2, 6, 12, 60, 60, 420, 840]
        A003418
    """
    return [RowLcmGcd(T.row, n, True) for n in range(size)]


def TablGcd(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the greatest common divisor (GCD) for each row in a table.
    Note our convention to exclude 0 and 1 from the terms.
    Args:
        T (Table): The table containing rows to process.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of GCD values for each row in the table.

    Example:
        >>> TablGcd(Fubini, 6)
        [1, 1, 2, 6, 2, 30]
        A141056, A027760
    """
    return [RowLcmGcd(T.row, n, False) for n in range(size)]


def TablMax(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the maximum absolute value in each row of a table.
    Note our convention to use the abs value.
    Args:
        T (Table): The table from which to calculate the maximum values.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of maximum absolute values for each row.

    Example:
        >>> TablMax(BinaryPell, 6)
        [1, 2, 4, 12, 32, 80]
        A109388
    """
    return [reduce(max, (abs(t) for t in T.row(n))) for n in range(size)]


def TablSum(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the sum of the elements of the first `size` rows.
    Args:
        T (Table): The table object containing the data.
        size (int, optional): The number of rows to sum. Defaults to 28.
    Returns:
        list[int]: A list of sums for each element in the specified range.

    Example:
        >>> TablSum(Binomial, 6)
        [1, 2, 4, 8, 16, 32]
        A000079
    """
    return [T.sum(n) for n in range(size)]


def EvenSum(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the sum of the even-indexed elements of the first `size` rows.
    Args:
        T (Table): The table object containing rows of data.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of sums of even-indexed elements for each row.

    Example:
        >>> EvenSum(Binomial, 6)
        [1, 1, 2, 4, 8, 16]
        A011782
    """
    return [sum(T.row(n)[::2]) for n in range(size)]


def OddSum(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the sum of the odd-indexed elements of the first `size` rows.
    Args:
        T (Table): The table object containing rows of data.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of sums of elements at odd indices for each row.

    Example:
        >>> OddSum(Binomial, 6)
        [0, 1, 2, 4, 8, 16]
        A131577
    """
    return [sum(T.row(n)[1::2]) for n in range(size)]


def AltSum(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the alternating sum of elements in each row of a table.
    Args:
        T (Table): The table from which rows are taken.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of the alternating sums of the rows.

    Example:
        >>> AltSum(Binomial, 6)
        [1, 0, 0, 0, 0, 0]
        A000007
    """
    return [sum(T.row(n)[::2]) - sum(T.row(n)[1::2]) for n in range(size)]


def AbsSum(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the absolute sum of each row in a table.
    Args:
        T (Table): The table from which to calculate the absolute sums.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of absolute sums of the rows.

    Example:
        >>> AbsSum(EulerTan, 6)
        [0, 1, 2, 5, 12, 41, 142]
        A009739
    """
    return [sum(abs(t) for t in T.row(n)) for n in range(size)]


def AccSum(T: Table, size: int = 28) -> list[int]:
    """
    Calculate the accumulated sum for the first 'size' rows of the table.
    Args:
        T (Table): The table the accumulated sums should be calculated.
        size (int, optional): The number of rows to calculate the accumulated sums. Defaults to 28.
    Returns:
        list[int]: A list of accumulated sums for each index from 0 to size-1.

    Example:
        >>> AccSum(Binomial, 6)
        [1, 3, 8, 20, 48, 112]
        A001792
    """
    return [sum(T.acc(n)) for n in range(size)]


def AccRevSum(T: Table, size: int = 28) -> list[int]:
    """
    Return the accumulated sums of the reversed rows for the given table.
    Args:
        T (Table): The table object containing revenue data.
        size (int, optional): The number of periods to calculate the accumulated sums for. Defaults to 28.
    Returns:
        list[int]: A list of accumulated sums of the reversed rows

    Example:
        >>> AccRevSum(StirlingCycle, 6)
        [1, 2, 5, 17, 74, 394]
        A000774
    """
    return [sum(accumulate(T.rev(n))) for n in range(size)]


def AntiDSum(T: Table, size: int = 28) -> list[int]:
    """
    Return the sum of the antidiagonals of a table.
    Args:
        T (Table): The table from which to calculate the antidiagonal sums.
        size (int, optional): The number of antidiagonals to sum. Defaults to 28.
    Returns:
        list[int]: A list of sums of the antidiagonals.

    Example:
        >>> AntiDSum(Binomial, 6)
        [1, 1, 2, 3, 5, 8]
        A000045
    """
    return [sum(T.antidiag(n)) for n in range(size)]


def ColMiddle(T: Table, size: int = 28) -> list[int]:
    """
    Return the middle column of a table.
    Args:
        T (Table): The table object from which to extract the column.
        size (int, optional): The number of elements to generate in the list. Defaults to 28.
    Returns:
        list[int]: A list of the middle terms of the given table.

    Example:
        >>> ColMiddle(Binomial, 6)
        [1, 1, 2, 3, 6, 10]
        A001405
    """
    return [T(n, n // 2) for n in range(size)]


def CentralE(T: Table, size: int = 28) -> list[int]:
    """
    Return the central column (terms of the form T(2n, n)) of a table.
    Args:
        T (Table): The table object from which to extract the column.
        size (int, optional): The number of elements to generate. Defaults to 28.
    Returns:
        list[int]: A list of the central terms of the given table.

    Example:
        >>> CentralE(Binomial, 6)
        [1, 2, 6, 20, 70, 252]
        A000984
    """
    return [T(2 * n, n) for n in range(size)]


def CentralO(T: Table, size: int = 28) -> list[int]:
    """
    Return the central column (terms of the form T(2n + 1, n)) of a table.
    Args:
        T (Table): The table object from which to extract the column.
        size (int, optional): The number of elements to generate. Defaults to 28.
    Returns:
        list[int]: A list of the central terms of the given table.

    Example:
        >>> CentralO(Binomial, 6)
        [1, 3, 10, 35, 126, 462]
        A001700
    """
    return [T(2 * n + 1, n) for n in range(size)]


def ColLeft(T: Table, size: int = 28) -> list[int]:
    """
    Extracts the leftmost column from a table.
    Args:
        T (Table): The table from which to extract the column.
        size (int, optional): The number of rows to extract. Defaults to 28.
    Returns:
        list[int]: A list containing the values from the leftmost column of the table.

    Example:
        >>> ColLeft(Nicomachus, 6)
        [1, 2, 4, 8, 16, 32]
        A000079
    """
    return [T(n, 0) for n in range(size)]


def ColRight(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of integers by applying the function T to each integer in the range from 0 to size-1.
    Args:
        T (Table): A function that takes two integer arguments and returns an integer.
        size (int, optional): The number of elements to generate. Defaults to 28.
    Returns:
        list[int]: A list of integers generated by applying T to each integer in the specified range.

    Example:
        >>> ColRight(Nicomachus, 6)
        [1, 3, 9, 27, 81, 243]
        A000244
    """
    return [T(n, n) for n in range(size)]


def PolyFrac(row: list[int], x: int) -> int:
    """
    Evaluate a polynomial with integer coefficients at a given point x.
    This function takes a list of coefficients representing a polynomial
    and evaluates the polynomial at the given value of x. The coefficients
    are assumed to be in descending order of powers.
    Args:
        row (list[int]): A list of integers representing the coefficients of the polynomial.
        x (int): The value at which to evaluate the polynomial.
    Returns:
        int: The result of the polynomial evaluation at x.
    """
    n = len(row) - 1
    return sum(c * x ** (n - k) for (k, c) in enumerate(row))


def PosHalf(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial fractions for the first half of the rows in the table.
    Args:
        T (Table): The table from which rows are taken.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of polynomial fractions for the specified rows.

    Example:
        >>> PosHalf(FallingFactorial, 6)
        [1, 3, 10, 38, 168, 872]
        A010842
    """
    return [PolyFrac(T.row(n), 2) for n in range(size)]


def NegHalf(T: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial fractions with a negative half exponent.
    Args:
        T (Table): The table from which rows are taken.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of polynomial fractions with a -2 exponent.

        Example:
        >>> NegHalf(FallingFactorial, 7)
        [1, -1, 2, -2, 8, 8, 112]
        A000023
    """
    return [PolyFrac(T.row(n), -2) for n in range(size)]


def TransNat0(T: Table, size: int = 28) -> list[int]:
    """
    Transforms the nonnegative numbers by the linear transformation represented by the table.
    Args:
        T (Table): The table to be transformed.
        size (int, optional): The size parameter for the transformation. Defaults to 28.
    Returns:
        list[int]: A list of the transformed nonnegative integers.

    Example:
        >>> TransNat0(Binomial, 6)
        [0, 1, 4, 12, 32, 80]
        A001787
    """
    return T.trans(lambda k: k, size)


def TransNat1(T: Table, size: int = 28) -> list[int]:
    """
    Transforms the positive numbers by the linear transformation represented by the table.
    Args:
        T (Table): The table to be transformed.
        size (int, optional): The length of the returned list. Defaults to 28.
    Returns:
        list[int]: A list of the transformed positive integers.

    Example:
        >>> TransNat1(Binomial, 6)
        [1, 3, 8, 20, 48, 112]
        A001792
    """
    return T.trans(lambda k: k + 1, size)


def TransSqrs(T: Table, size: int = 28) -> list[int]:
    """
    Transforms the squares by the linear transformation represented by the table.
    Args:
        T (Table): The table considered as a linear transformation.
        size (int, optional): The length of the returned list. Defaults to 28.
    Returns:
        list[int]: The list of the transformed squares.

    Example:
        >>> TransSqrs(Lah, 6)
        [0, 1, 6, 39, 292, 2505]
        A103194
    """
    return T.trans(lambda k: k * k, size)


def BinConv(T: Table, size: int = 28) -> list[int]:
    """
    Transforms the table by computing the dot product of the n-th row of T with the n-th row of the binomial triangle.
    Args:
        T (Table): The input table with the rows to be transformed.
        size (int, optional): The number of rows th be processed. Defaults to 28.
    Returns:
        list[int]: A list of integers representing the binomial convolution of the given table.

    Example:
        >>> BinConv(FallingFactorial, 6)
        [1, 2, 7, 34, 209, 1546]
        A002720
    """
    return [dotproduct(Binomial.row(n), T.row(n)) for n in range(size)]


def InvBinConv(T: Table, size: int = 28) -> list[int]:
    """
    Transforms the table by computing the dot product of the n-th row of T with the n-th row of the inverse binomial triangle.
    Args:
        T (Table): The input table with the rows to be transformed.
        size (int, optional): The number of rows th be processed. Defaults to 28.
    Returns:
        list[int]: A list of integers representing the inverse binomial convolution of the given table.

    Example:
        >>> InvBinConv(FallingFactorial, 6)
        [1, 0, -1, -4, -15, -56]
        A009940
    """
    return [dotproduct(InvBinomial.row(n), T.row(n)) for n in range(size)]


def RevToff11(t: Table, size: int = 8) -> list[int]:
    """
    Generates a list of integers by reversing the given table, offsetting it by (1, 1),
    and flattening the result to the specified size.
    Args:
        t (Table): The input table to be reversed and processed.
        size (int, optional): The size of the flattened list to be returned. Defaults to 8.
    Returns:
        list[int]: A flattened list of integers from the processed table.
    """
    T = RevTable(t)
    T11 = Table(T.off(1, 1), T.id + "off11")
    return T11.flat(size)


def RevTrev11(t: Table, size: int = 8) -> list[int]:
    """
    Generates a list of integers by applying the rev11 method of the RevTable class to a given Table object.
    Args:
        t (Table): The Table object to be processed.
        size (int, optional): The number of times to apply the rev11 method. Defaults to 8.
    Returns:
        list[int]: A flattened list of integers resulting from the rev11 method applied to the Table object.
    """
    T = RevTable(t)
    return list(flatten([T.rev11(n) for n in range(size)]))


def RevTinv11(t: Table, size: int = 8) -> list[int]:
    """
    Computes the inverse of the table `t` and flattens the result.
    Args:
        t (Table): The table to be inverted.
        size (int, optional): The size parameter for the inversion. Defaults to 8.
    Returns:
        list[int]: A flattened list of the inverted table.
    """
    T = RevTable(t)
    InvT11 = T.inv11(size)
    return list(flatten(InvT11))


def RevTalt(t: Table, size: int = 7) -> list[int]:
    """
    Generate a list of integers by reversing the table and flattening the alternates.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of alternates to consider. Defaults to 7.
    Returns:
        list[int]: A flattened list of integers from the alternates of the reversed table.
    """
    T = RevTable(t)
    return list(flatten([T.alt(n) for n in range(size)]))


def RevTacc(t: Table, size: int = 7) -> list[int]:
    """
    Generate a list of accumulated values from a reversed table.
    Args:
        t (Table): The table to be reversed and processed.
        size (int, optional): The number of accumulations to perform. Defaults to 7.
    Returns:
        list[int]: A flattened list of accumulated values from the reversed table.
    """
    T = RevTable(t)
    return list(flatten([T.acc(n) for n in range(size)]))


def RevTder(t: Table, size: int = 8) -> list[int]:
    """
    Generate a list of derivatives from a reversed table.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of derivatives to compute. Defaults to 8.
    Returns:
        list[int]: A flattened list of derivatives from the reversed table.
    """
    T = RevTable(t)
    return list(flatten([T.der(n) for n in range(size)]))


def RevTantidiag(t: Table, size: int = 9) -> list[int]:
    """
    Generates a list of integers from the reversed table's antidiagonals.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of antidiagonals to consider. Defaults to 9.
    Returns:
        list[int]: A flattened list of integers from the reversed table's antidiagonals.

    Example:
        >>> Rev_Tantidiag(Leibniz, 5)
        [1, 2, 3, 2, 4, 6, 5, 12, 3]
        A128502
    """
    T = RevTable(t)
    return list(flatten([T.antidiag(n) for n in range(size)]))


def RevPolyRow1(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values from a reversed table.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values of degree 1 from the reversed table.
    """
    T = RevTable(t)
    return [T.poly(1, x) for x in range(size)]


def RevPolyRow2(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of degree 2 from a reversed table.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values of degree 2.
    """
    T = RevTable(t)
    return [T.poly(2, x) for x in range(size)]


def RevPolyRow3(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of degree 3 for a given table.
    This function takes a table `t` and generates a list of polynomial values
    of degree 3 for each element in the range of `size`. The table is first
    reversed using the `RevTable` function, and then the polynomial values
    are computed.
    Args:
        t (Table): The input table to be reversed and processed.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values of degree 3.
    """
    T = RevTable(t)
    return [T.poly(3, x) for x in range(size)]


def RevPolyCol3(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial values of degree 3 from a reversed table.
    Args:
        t (Table): The input table.
        size (int, optional): The number of polynomial values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial values of degree 3.
    """
    T = RevTable(t)
    return [T.poly(x, 3) for x in range(size)]


def RevPolyDiag(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial diagonal values from a reversed table.
    Args:
        t (Table): The input table.
        size (int, optional): The number of diagonal values to generate. Defaults to 28.
    Returns:
        list[int]: A list of polynomial diagonal values.

    Example:
        >>> Rev_PolyDiag(Narayana, 6)
        [1, 1, 3, 19, 185, 2426]
        A242369
    """
    T = RevTable(t)
    return [T.poly(n, n) for n in range(size)]


def RevEvenSum(t: Table, size: int = 28) -> list[int]:
    """
    Calculate the sum of even-indexed elements in each row of the reversed table.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of sums of even-indexed elements for each row.
    """
    T = RevTable(t)
    return [sum(T.row(n)[::2]) for n in range(size)]


def RevOddSum(t: Table, size: int = 28) -> list[int]:
    """
    Calculate the sum of odd-indexed elements in each row of the reversed table.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list containing the sum of odd-indexed elements for each row.
    """
    T = RevTable(t)
    return [sum(T.row(n)[1::2]) for n in range(size)]


def RevAccRevSum(t: Table, size: int = 28) -> list[int]:
    """
    Calculate the accumulated row sums of the reversed table.
    Args:
        t (Table): The input table.
        size (int, optional): The number of rows to process. Defaults to 28.
    Returns:
        list[int]: A list of accumulated sums for each row in the reversed table.
    """
    T = RevTable(t)
    return [sum(accumulate(T.rev(n))) for n in range(size)]


def RevAntiDSum(t: Table, size: int = 28) -> list[int]:
    """
    Calculate the sums of the antidiagonals of the reversed table.
    Args:
        t (Table): The input table.
        size (int, optional): The number of antidiagonals to sum. Defaults to 28.
    Returns:
        list[int]: A list of sums of the antidiagonals of the reversed table.

    Example:
        >>> Rev_AntiDSum(Narayana, 6)
        [1, 1, 1, 2, 4, 8]
        A004148
    """
    T = RevTable(t)
    return [sum(T.antidiag(n)) for n in range(size)]


def RevColMiddle(t: Table, size: int = 28) -> list[int]:
    """
    Generates a list of integers by reversing the table and selecting the middle column.
    Args:
        t (Table): The input table to be reversed.
        size (int, optional): The number of elements to generate. Defaults to 28.
    Returns:
        list[int]: A list of integers from the middle column of the reversed table.
    """
    T = RevTable(t)
    return [T(n, n // 2) for n in range(size)]


def RevCentralO(t: Table, size: int = 28) -> list[int]:
    """
    Generate the central elements T(2n + 1, n) of the reversed table.
    Args:
        t (Table): The input table.
        size (int, optional): The number of elements to generate in the list. Defaults to 28.
    Returns:
        list[int]: The list of the central elements of the reversed table.
    """
    T = RevTable(t)
    return [T(2 * n + 1, n) for n in range(size)]


def RevPosHalf(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial fractions for reversed elements of a table.
    Args:
        t (Table): The table object containing elements to be reversed.
        size (int, optional): The number of elements to process. Defaults to 28.
    Returns:
        list[int]: A list of polynomial fractions for the reversed elements.

    Example:
        >>> Rev_PosHalf(Narayana, 6)
        [1, 2, 6, 22, 90, 394]
        A152681
    """
    return [PolyFrac(t.rev(n), 2) for n in range(size)]


def RevNegHalf(t: Table, size: int = 28) -> list[int]:
    """
    Generate a list of polynomial fractions with a negative half exponent.
    This function takes a Table object and generates a list of polynomial fractions
    with an exponent of -2 for each element in the table, reversed up to the specified size.
    Args:
        t (Table): The table object containing the elements to be processed.
        size (int, optional): The number of elements to process. Defaults to 28.
    Returns:
        list[int]: A list of polynomial fractions with a negative half exponent.

    Example:
        Rev_NegHalf(Narayana, 6)
        [1, -2, 2, 2, -10, 6]
        A152681
    """
    return [PolyFrac(t.rev(n), -2) for n in range(size)]


def RevTransNat0(t: Table, size: int = 28) -> list[int]:
    """
    Reverse the given table and transform its elements.
    This function takes a table `t`, reverses it using the `RevTable` function,
    and then applies a transformation to its elements using the `trans` method.
    The transformation applied is the identity function (i.e., each element is
    mapped to itself).
    Args:
        t (Table): The table to be reversed and transformed.
        size (int, optional): The size parameter to be passed to the `trans` method. Defaults to 28.
    Returns:
        list[int]: A list of integers resulting from the transformation.

    Example:
        >>> Rev_TransNat0(StirlingCycle, 6)
        [0, 0, 1, 7, 46, 326]
        A067318
    """
    T = RevTable(t)
    return T.trans(lambda k: k, size)


def RevTransNat1(t: Table, size: int = 28) -> list[int]:
    """
    Reverse the given table and transform its elements by adding 1.
    Args:
        t (Table): The table to be reversed and transformed.
        size (int, optional): The size parameter for the transformation. Defaults to 28.
    Returns:
        list[int]: A list of integers resulting from the transformation.

    Example:
        >>> Rev_TransNat1(StirlingCycle, 6)
        [1, 1, 3, 13, 70, 446]
        A121586
    """
    T = RevTable(t)
    return T.trans(lambda k: k + 1, size)


def RevTransSqrs(t: Table, size: int = 28) -> list[int]:
    """
    Applies a transformation to the given table by reversing it and then squaring each element.
    Args:
        t (Table): The input table to be transformed.
        size (int, optional): The size parameter for the transformation. Defaults to 28.
    Returns:
        list[int]: A list of integers resulting from the transformation.

    Example:
        >>> Rev_TransSqrs(Binomial, 6)
        [0, 1, 6, 24, 80, 240]
        A001788
    """
    T = RevTable(t)
    return T.trans(lambda k: k * k, size)


"""The basic construction is a map
    (Table:Class, Trait:Function) -> (Anum:Url, TreatInfo:TeXString)
"""
TraitInfo: TypeAlias = Tuple[Trait, int, str]
"""The dictionary of all traits with their respective functions and TeX strings.
   The size of the table is set to 7, 9 or 28 rows for the default case.
   It is mandatory that this dictionary starts with the key 'Triangle'!
"""
AllTraits: dict[str, TraitInfo] = {
    "Triangle     ": (Triangle, 7, r"\(T_{n,k}\)"),
    "Tinv         ": (Tinv, 7, r"\(T^{-1}_{n,k}\)"),
    "Trev         ": (Trev, 7, r"\(T_{n,n-k}\)"),
    "Tinvrev      ": (Tinvrev, 7, r"\((T_{n,n-k})^{-1}\)"),
    "Trevinv      ": (Trevinv, 7, r"\((T_{n,n-k})^{-1}\)"),
    "Toff11       ": (Toff11, 7, r"\(T_{n+1,k+1} \)"),
    "Trev11       ": (Trev11, 7, r"\(T_{n+1,n-k+1} \)"),
    "Tinv11       ": (Tinv11, 7, r"\(T^{-1}_{n+1,k+1}\)"),
    "Tinvrev11    ": (Tinvrev11, 7, r"\((T_{n+1,n-k+1})^{-1}\)"),
    "Trevinv11    ": (Trevinv11, 7, r"\((T^{-1}_{n+1,n-k+1})\)"),
    "Tantidiag    ": (Tantidiag, 9, r"\(T_{n-k,k}\ \ (k \le n/2)\)"),
    "Tacc         ": (Tacc, 7, r"\(\sum_{j=0}^{k} T_{n,j}\)"),
    "Talt         ": (Talt, 7, r"\(T_{n,k}\ (-1)^{k}\)"),
    "Tder         ": (Tder, 8, r"\(T_{n,k+1}\ (k+1) \)"),
    "TablCol0     ": (TablCol0, 28, r"\(T_{n  ,0}\)"),
    "TablCol1     ": (TablCol1, 28, r"\(T_{n+1,1}\)"),
    "TablCol2     ": (TablCol2, 28, r"\(T_{n+2,2}\)"),
    "TablCol3     ": (TablCol3, 28, r"\(T_{n+3,3}\)"),
    "TablDiag0    ": (TablDiag0, 28, r"\(T_{n  ,n}\)"),
    "TablDiag1    ": (TablDiag1, 28, r"\(T_{n+1,n}\)"),
    "TablDiag2    ": (TablDiag2, 28, r"\(T_{n+2,n}\)"),
    "TablDiag3    ": (TablDiag3, 28, r"\(T_{n+3,n}\)"),
    "TablLcm      ": (TablLcm, 28, r"\(\text{lcm} \{ \ \| T_{n,k} \| : k=0..n \} \)"),
    "TablGcd      ": (TablGcd, 28, r"\(\text{gcd} \{ \ \| T_{n,k} \| : k=0..n \} \)"),
    "TablMax      ": (TablMax, 28, r"\(\text{max} \{ \ \| T_{n,k} \| : k=0..n \} \)"),
    "TablSum      ": (TablSum, 28, r"\(\sum_{k=0}^{n} T_{n,k}\)"),
    "EvenSum      ": (EvenSum, 28, r"\(\sum_{k=0}^{n} T_{n,k}\ ( 2 \mid k) \)"),
    "OddSum       ": (OddSum, 28, r"\(\sum_{k=0}^{n} T_{n,k}\ (1 - (2 \mid k)) \)"),
    "AltSum       ": (AltSum, 28, r"\(\sum_{k=0}^{n} T_{n,k}\ (-1)^{k}\)"),
    "AbsSum       ": (AbsSum, 28, r"\(\sum_{k=0}^{n} \| T_{n,k} \| \)"),
    "AccSum       ": (AccSum, 28, r"\(\sum_{k=0}^{n} \sum_{j=0}^{k} T_{n,j}\)"),
    "AccRevSum    ": (AccRevSum, 28, r"\(\sum_{k=0}^{n} \sum_{j=0}^{k} T_{n,n-j}\)"),
    "AntiDSum     ": (AntiDSum, 28, r"\(\sum_{k=0}^{n/2} T_{n-k, k}\)"),
    "ColMiddle    ": (ColMiddle, 28, r"\(T_{n, n / 2}\)"),
    "CentralE     ": (CentralE, 28, r"\(T_{2 n, n}\)"),
    "CentralO     ": (CentralO, 28, r"\(T_{2 n + 1, n}\)"),
    "PosHalf      ": (PosHalf, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ 2^{n-k} \)"),
    "NegHalf      ": (NegHalf, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ (-2)^{n-k} \)"),
    "TransNat0    ": (TransNat0, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ k\)"),
    "TransNat1    ": (TransNat1, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ (k+1)\)"),
    "TransSqrs    ": (TransSqrs, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ k^{2}\)"),
    "BinConv      ": (BinConv, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ \binom{n}{k} \)"),
    "InvBinConv   ": (
        InvBinConv,
        28,
        r"\(\sum_{k=0}^{n}T_{n,k}\ (-1)^{n-k}\ \binom{n}{k}\)",
    ),
    "PolyRow1     ": (PolyRow1, 28, r"\(\sum_{k=0}^{1}T_{1,k}\ n^k\)"),
    "PolyRow2     ": (PolyRow2, 28, r"\(\sum_{k=0}^{2}T_{2,k}\ n^k\)"),
    "PolyRow3     ": (PolyRow3, 28, r"\(\sum_{k=0}^{3}T_{3,k}\ n^k\)"),
    "PolyCol2     ": (PolyCol2, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ 2^k\)"),
    "PolyCol3     ": (PolyCol3, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ 3^k\)"),
    "PolyDiag     ": (PolyDiag, 28, r"\(\sum_{k=0}^{n}T_{n,k}\ n^k\)"),
    "RevToff11    ": (RevToff11, 7, r"\(T_{n+1,n-k} \)"),
    "RevTrev11    ": (RevTrev11, 7, r"\(T_{n+1,n-k} \)"),
    "RevTinv11    ": (RevTinv11, 7, r"\(T^{-1}_{n+1,n-k}\)"),
    "RevTantidiag ": (RevTantidiag, 9, r"\(T_{n-k,n-2k}\ \ (k \le n/2)\)"),
    "RevTacc      ": (RevTacc, 7, r"\(\sum_{j=0}^{n-k}T_{n,n-j}\)"),
    "RevTalt      ": (RevTalt, 7, r"\(T_{n,n-k}\ (-1)^{n-k}\)"),
    "RevTder      ": (RevTder, 8, r"\(T_{n+1,n-k}\ (n-k+1) \)"),
    "RevEvenSum   ": (RevEvenSum, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ (2 \mid k) \)"),
    "RevOddSum    ": (RevOddSum, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ (1- (2 \mid k)) \)"),
    "RevAccRevSum ": (RevAccRevSum, 28, r"\(\sum_{k=0}^{n} \sum_{j=0}^{k}T_{n,n-j}\)"),
    "RevAntiDSum  ": (RevAntiDSum, 28, r"\(\sum_{k=0}^{n/2}T_{n-k,n-k}\)"),
    "RevColMiddle ": (RevColMiddle, 28, r"\(T_{n, n/2}\)"),
    "RevCentralO  ": (RevCentralO, 28, r"\(T_{2n+1,n}\)"),
    "RevPosHalf   ": (RevPosHalf, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ 2^{n-k} \)"),
    "RevNegHalf   ": (RevNegHalf, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ (-2)^{n-k} \)"),
    "RevTransNat0 ": (RevTransNat0, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ k\)"),
    "RevTransNat1 ": (RevTransNat1, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ (k + 1)\)"),
    "RevTransSqrs ": (RevTransSqrs, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ k^{2}\)"),
    "RevPolyRow1  ": (RevPolyRow1, 28, r"\(\sum_{k=0}^{1}T_{1,n-k}\ n^k\)"),
    "RevPolyRow2  ": (RevPolyRow2, 28, r"\(\sum_{k=0}^{2}T_{2,n-k}\ n^k\)"),
    "RevPolyRow3  ": (RevPolyRow3, 28, r"\(\sum_{k=0}^{3}T_{3,n-k}\ n^k\)"),
    "RevPolyCol3  ": (RevPolyCol3, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ 3^k\)"),
    "RevPolyDiag  ": (RevPolyDiag, 28, r"\(\sum_{k=0}^{n}T_{n,n-k}\ n^k\)"),
}


def TableTraits(T: Table) -> None:
    """
    Processes and prints traits of a given table.
    Args:
        T (Table): The table object whose traits are to be processed.
    Iterates over all traits in the AllTraits dictionary, constructs a name
    for each trait by combining the table's ID and the trait ID, and prints
    the name and the corresponding trait's TeXed formula. Additionally, converts the
    trait's sequence to a string and prints it.
    The name can be used as a key into the dictionary of T.
    The sequence is converted to a string with a maximum line length of 60 and
    a maximum of 20 terms.
    Returns:
        None
    """
    for trait_id, tr in AllTraits.items():
        name = (T.id + "_" + trait_id).ljust(9 + len(T.id), " ")
        tex = tr[2]
        seq = tr[0](T, tr[1])
        print(name, tex)
        # print(FNVhash(SeqToString(seq, 180, 50, ",", 3, True)))
        print(SeqToString(seq, 60, 20))


GlobalDict: Dict[str, Dict[str, int]] = {}


def GetRoot(name: str = "") -> Path:
    path = Path(__file__).parent.parent
    return (path / name).resolve()


def ShowGlobalDict() -> None:
    """Dump the global dictionary to std-out."""
    global GlobalDict
    for tabl, dict in GlobalDict.items():
        print(f"*** Table {tabl} ***")
        for trait in dict:
            print(f"    {trait} -> {dict[trait]}")


def ReadJsonDict() -> Dict[str, Dict[str, int]]:
    """Loaded the file data/AllTraits.json into the global dictionary GlobalDict.
    In case of a FileNotFoundError a new empty dictionary is created.
    Returns:
        Dict[str, Dict[str, int]]: A global dictionary containing traits dictionaries.
    """
    global GlobalDict
    jsonpath = GetRoot(f"data/AllTraits.json")
    try:
        with open(jsonpath, "r") as file:
            GlobalDict = json.load(file)
    except FileNotFoundError:
        print("No file 'AllTraits.json' found.")
        GlobalDict = {}
        print("New GlobalDict created.")
        return GlobalDict
    print("GlobalDict loaded with file AllTraits.json!")
    return GlobalDict


def FilterDict(olddict: Dict[str, int]) -> Dict[str, int]:
    """Make a new dictionary with unique A-numbers.
    Args:
        olddict (Dict[str, int]): A-numbers can appear several times.
    Returns:
        Dict[str, int]: A-numbers can appear at most once.
    """
    anumlist: set[int] = set()
    newdict: Dict[str, int] = {}
    for k, v in olddict.items():
        if not v in anumlist:
            newdict[k] = v
        anumlist.add(v)
    return newdict


def TruncateInfo(srcpath: Path) -> None:
    """
    The function reads the file line by line and writes back the content
    up to (but not including) the line that starts with the OEIS marker
    (''' OEIS). Once the marker is found, the file is truncated at that point.
    Args:
        srcpath (Path): The path to the file to be truncated.
    """
    oeis_marker = "''' OEIS"
    with open(srcpath, "r", encoding="utf-8") as f:
        lines = f.readlines()
    with open(srcpath, "w", encoding="utf-8") as f:
        for line in lines:
            if line.startswith(oeis_marker):
                f.truncate(f.tell())
                break
            f.write(line)


def AddAnumsToSrcfile(name: str, dict: Dict[str, int] = {}) -> None:
    """Add an OEIS section to the source file of a table.
    Args:
        name (str): name of the table
        dict (Dict[str, int], optional): where the OEIS infos are.
        Defaults to {} which in turn triggers the use of the gloabl dictionary.
    Example:
       AddAnumsToSrcfile("Catalan") will add the following line to src/Catalan.py
       indicatting the OEIS A-number of the row sums of the Catalan triangle.
       Catalan_TablSum -> https://oeis.org/A1700
    """

    global GlobalDict
    if dict == {}:
        ReadJsonDict()
        dict = GlobalDict[name]
    srcpath = GetRoot(f"src/{name}.py")
    TruncateInfo(srcpath)
    with open(srcpath, "a+", encoding="utf-8") as dest:
        d = {k: v for k, v in sorted(dict.items(), key=lambda item: item[1])}
        dest.write("\n\n" + r"'''" + " OEIS\n")
        for fullname, anum in d.items():
            if anum != 0:
                dest.write(f"    {fullname} -> https://oeis.org/A{anum}\n")
            else:
                dest.write(f"    {fullname} -> 0 \n")
        misses = len([v for v in d.values() if v == 0])
        hits = len(d.values()) - misses
        distincts = len(set(d.values()))
        dest.write(
            f"\n    {name}: Distinct: {distincts}, Hits: {hits}, Misses: {misses}"
        )
        dest.write("\n" + r"'''" + "\n")


def AnumberDict(
    T: Table, info: bool = False, addtoglobal: bool = False
) -> Dict[str, int]:
    """Collects the A-numbers of the traits of the given table that are present in the OEIS.
    Requires online access to the OEIS database.
    Args:
        T (Table): table for which the OEIS data is seeked
        info (bool, optional): Prints infos while quering the OEIS database. Defaults to False.
        addtoglobal (bool, optional): add the generated dict to the global dict. Defaults to False.
    Returns:
        Dict[str, int]: _description_
    """

    global GlobalDict
    print(f"*** Table {T.id} under construction ***")
    trait_dict: Dict[str, int] = {}
    for trid, tr in AllTraits.items():
        # the key of the dictionary is the table name + trait name.
        name = (T.id + "_" + trid).ljust(10 + len(T.id), " ")
        if info:
            print(name)
        # generate the trait data for the query
        seq: list[int] = tr[0](T, tr[1])
        if seq != []:
            trait_dict[name] = QueryOEIS(seq, info)
    if addtoglobal:
        GlobalDict[T.id] = trait_dict
    return trait_dict


header = r'<!DOCTYPE html lang="en"><head><title>NAMEXXX</title><meta charset="utf-8"><meta name="viewport" content="width=device-width"><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">window.MathJax={ loader:{ load: ["[tex]/bbox"]}, tex:{ packages:{ "[+]": ["bbox"]}}}</script><style type="text/css">table{ margin-top: 8px; display: inline-block;} table.rTable{ position: fixed; top: 0px; border: 2px solid #5949b3; background-color: #EEE7DB; text-align: center; border-collapse: collapse; font-family: "Segoe UI", sans-serif; font: 1em sans-serif; overflow-y: auto; max-height: 850px;} table.rTable td, table.rTable th{ border: 1px solid #AAAAAA; padding: 8px 2px;} table.rTable tbody td{ font-size: 16px;} table.rTable tr:nth-child(even){ background: #f3f1f0;} table.rTable thead{ background: #585ada;} table.rTable thead th{ font-size: 16px; font-weight: bold; color: #FFFFFF; text-align: center; border-left: 2px solid #A40808;} </style></head><body><iframe name="OEISframe" scrolling="yes" width="70%" height="850" align="left" title="Sequences" src=https://oeis.org/AXXXXXX></iframe><div style="height:850px; overflow:auto;"><table class="rTable"><thead><tr><th>OEIS</th><th>TRAIT</th><th>FORMULA</th></tr></thead><tbody><tr><td><a href="https://oeis.org/AXXXXXX" target="OEISframe">AXXXXXX</a></td><td style="color: darkgreen;font-weight:800">NAMEXXX</td><td style="color: darkgreen;font-weight:800">\(T_{n,k}\)</td></tr>'


def DictToHtml(
    T: Table, dict: Dict[str, int], info: bool = False
) -> tuple[int, int, int]:
    """Transforms a dictionary {trait, anum} of the Table T
    into two html files: TNameTraits.html and TNameMissing.html.
    A trait is 'missing' if the anum in the dictionary is 0.
    """
    hitpath = GetRoot(f"docs/{T.id}Traits.html")
    head = header.replace("NAMEXXX", T.id).replace("AXXXXXX", f"{T.oeis[0]}")
    hits = misses = doubles = 0
    anumlist: set[int] = set()
    with open(hitpath, "w+", encoding="utf-8") as oeis:
        oeis.write(head)
        d = {k: v for k, v in sorted(dict.items(), key=lambda item: item[1])}
        for fullname, anum in d.items():
            if info:
                print(f"    {fullname} -> {anum}")  # prints sorted dict
            traitfun, size, tex = AllTraits[fullname.split("_")[1]]  # type: ignore
            if anum == 0:
                continue
            if anum in anumlist:
                doubles += 1
            Anum = "A" + str(anum).rjust(6, "0")
            url = f"<a href='https://oeis.org/{Anum}' target='OEISframe'>{Anum}</a>"
            row = f"<tr><td>{url}</td><td>{fullname.split('_')[1]}</td><td>{tex}</td></tr>"
            oeis.write(row)
            hits += 1
            anumlist.add(anum)

        row = f"<tr><td colspan='3'><a href='https://peterluschny.github.io/tablInspector/index.html'>I N D E X</a></td></tr></tbody></table></div></body></html>"
        oeis.write(row)
    distincts = len(anumlist)
    print(f"{T.id:17}, Distinct: {distincts}, Hits: {hits}, Misses: {misses}")
    return (distincts, hits, misses)


def RefreshHtml(filter: bool = False) -> None:
    """
    Refreshes the HTML representation of tables based on the global dictionary.
    This function reads the global dictionary from a JSON file, iterates over a list of tables,
    and converts each table's dictionary to HTML. If the `filter` parameter is set to True,
    the dictionary multiple A-numbers are removed.
    Args:
        filter (bool): If True, multiple A-numbers are removed before conversion. Defaults to False.
    Raises:
        KeyError: If a table's ID is not found in the global dictionary.
    """
    global GlobalDict
    ReadJsonDict()

    indexpath = GetRoot(f"docs/index.html")
    with open(indexpath, "w+", encoding="utf-8") as index:
        index.write(indheader)
        for T in TablesList:
            try:
                dict = GlobalDict[T.id]
                if filter:
                    dict = FilterDict(dict)
                DictToHtml(T, dict)  # type: ignore
                index.write(
                    f"<tr><td align='left'><a href='{T.id}Traits.html'>{T.id}</a></td></tr>"
                )
                print(T.id, "dict length:", len(dict))
            except KeyError as e:
                print("KeyError:", e)
                input()
                pass

        index.write("</tbody></table></body></html>")
        index.flush()


indheader = "<!DOCTYPE html><html lang='en'><head><title>Index</title><meta name='viewport' content='width=device-width,initial-scale=1'><style type='text/css'>body{ font-family: Calabri, Arial, sans-serif; font-size: 16px; background-color: yellow; color: #0f0f0f} a{ text-decoration: none;} tbody td:hover{ background-color: greenyellow;} table, td,th{ border: 2px solid black; border-collapse: collapse; margin-left: 16px; padding-left: 10px; padding-top: 4px;} </style><base href='https://peterluschny.github.io/tablInspector/' target='_blank'></head><body><table><thead><tr><th align='left'>Triangle Inspector</th></tr></thead><tbody><tr>"


def RefreshDatabase() -> None:
    """Generates the traits for all tables in TablesList and writes them
    in html format to files in the docs directory. Furthermore, the
    trait dictionaries are saved in a dictionary in JSON format that
    is written to the data directory.
    """
    print("Warning: This will take some time.")
    global GlobalDict
    ReadJsonDict()
    indexpath = GetRoot(f"docs/index.html")
    with open(indexpath, "w+", encoding="utf-8") as index:
        index.write(indheader)
        for T in TablesList:
            dict = AnumberDict(T, True, True)  # type: ignore
            DictToHtml(T, dict, False)  # type: ignore
            index.write(
                f"<tr><td align='left'>{T.id}</td><td align='left'><a href='{T.id}Traits.html'>[online]</a></td></tr>"
            )
            AddAnumsToSrcfile(T.id, dict)
        index.write("</tbody></table></body></html>")
        index.flush()
    # Save to a JSON file
    jsonpath = GetRoot(f"data/AllTraits.json")
    with open(jsonpath, "w") as fileson:
        json.dump(GlobalDict, fileson)


def AddTable(T: Table, dict: Dict[str, int] = {}) -> Dict[str, int]:
    """
    Adds a table to a dictionary, i.e. it reads a JSON dictionary,
    updates it with the provided table, and converts the dictionary to HTML.
    Args:
        T (Table): The table to be added.
        dict (Dict[str, int], optional): A dictionary to be updated.
        Defaults to an empty dictionary.
    Returns:
        Dict[str, int]: The updated dictionary.
    """
    ReadJsonDict()
    if dict == {}:  # info, add2globalDict
        dict = AnumberDict(T, True, True)
    print("Dict length:", len(dict))
    DictToHtml(T, dict, True)
    jsonpath = GetRoot(f"data/AllTraits.json")
    with open(jsonpath, "w+") as fileson:
        json.dump(GlobalDict, fileson)
    return dict


def TraitOccurences() -> Dict[str, set[int]]:
    """
    Generates a dictionary of traits with sets of A-numbers from the global dictionary.
    Each key is a trait identifier and the value is a set of A-numbers associated
    with that trait in some triangle.
    Returns:
        Dict[str, set[int]]: A dictionary where each key is a trait identifier
        and the value is a set of A-numbers.
    """
    global GlobalDict
    ReadJsonDict()
    trdict: Dict[str, set[int]] = {trid: set() for trid in AllTraits.keys()}
    for T in TablesList:
        for trid in AllTraits.keys():
            # the key of the dictionary is the table name + trait name.
            key = (T.id + "_" + trid).ljust(10 + len(T.id), " ")
            trdict[trid].add(GlobalDict[T.id].get(key, 1))
    return trdict


def GetAnumOccurence(lookup: int) -> list[str]:
    """
    Generates a dictionary of traits
    Returns:
        list[str]: A list where each key is a trait identifier
        and the value is a set of A-numbers.
    """
    global GlobalDict
    ReadJsonDict()
    trdict: list[str] = []
    for T in TablesList:
        for trid in AllTraits.keys():
            # the key of the dictionary is the table name + trait name.
            key = (T.id + "_" + trid).ljust(10 + len(T.id), " ")
            anum = GlobalDict[T.id].get(key, 1)
            if anum == lookup:
                trdict.append(f"{trid.replace(" ", "") }({T.id})")
    return trdict


def InspectTable(T: Table, oeis: bool = False) -> None:
    """
    Prints the table traits. If the option oeis is True,
    the A-numbers of the traits of T will be searched online
    and added to the global dictionary and also to the
    file 'data/AllTraits.json'.

    Args:
        T, table to inspect
        oeis, search OEIS for A-numbers of the traits of T.
        Defaults to False.
    Returns:
    None.
    """
    print()
    TableTraits(T)
    print()
    print("NAME       ", T.id)
    print("Formula    ", T.tex)
    print("Similars   ", T.oeis)
    print("Inverse    ", T.invid if T.invQ else "None")
    print("Timing 100 rows:", end="")
    TableGenerationTime(T)
    print()
    print("TABLE")
    T.show(10)
    print()
    if oeis:
        print("Searching OEIS -- this will take some time!")
        AddTable(T)
        print()


class Rank(NamedTuple):
    anum: str
    name: str
    distinct: int
    hits: int
    misses: int


def Ranking() -> Dict[int, Rank]:
    globaldict: Dict[str, Dict[str, int]] = ReadJsonDict()
    ranks: list[Rank] = []
    for name in globaldict:
        v = list(globaldict[name].values())
        a = len(v)
        d = len(set(v))
        m = len([k for k in v if k == 0])
        w = v[0] if v[0] != 0 else v[3]  # if not (0,0) then (1,1)
        anum = "A" + str(w).rjust(6, "0")
        ranks.append(Rank(anum, name, d, a - m, m))
    sorted_ranks = sorted(ranks, key=itemgetter(2), reverse=True)
    Rankings = {n: r for n, r in enumerate(sorted_ranks)}
    # IO = "https://peterluschny.github.io/tabl"
    print("\nRanking of triangles with regard to their impact:\n")
    print()
    print("|   | Name             |  OEIS |Distinct| Hits | Traits | Links |")
    print("| :-: | :---           | :---:  | :---:   |  :---: |  :---:  |  :---: |")
    for n, r in Rankings.items():
        print(
            f"| {(n+1):2}| {r.name}       |{r.anum}|  {r.distinct:2}    | {r.hits:2}| [All](https://peterluschny.github.io/tabl/{r.name}.html)   | [OEIS](https://peterluschny.github.io/tablInspector/{r.name}Traits.html) |"
        )
    return Rankings


def ListOccurences() -> None:
    """
    Generates and prints a list of sequences that occur most frequently in a given dataset.
    This function reads a dictionary from a JSON file, where the keys are the names of
    triangles and the values are dictionaries mapping traits to OEIS A-numbers. It then
    counts the occurrences of each A-number and stores the names associated with each A-number.
    If an A-number is associated with more than 10 triangles, it is added to a list along
    with the count of the triangles. The list is sorted in descending order based on the
    count and printed.
    """
    Occurences: Dict[int, list[str]] = {}
    globdict: Dict[str, Dict[str, int]] = ReadJsonDict()
    li: set[int] = set()
    for d in globdict.values():
        for name, anum in d.items():
            li.add(anum)
            if anum in Occurences:
                Occurences[anum].append(name)
            else:
                Occurences[anum] = [name]
    # print(sorted(li), len(li))  # show all sequences generated

    w: list[tuple[str, int]] = []
    for anum, names in Occurences.items():
        if len(names) > 10:
            Anum = "A" + str(anum).rjust(6, "0")
            w.append((Anum, len(names)))
    # Show a list of the sequences most often found.
    w.sort(key=lambda x: x[1], reverse=True)
    for x in w[1:]:
        print(x)


@cache
def abel(n: int) -> list[int]:
    if n == 0:
        return [1]
    b = binomial(n - 1)
    return [b[k - 1] * n ** (n - k) if k > 0 else 0 for k in range(n + 1)]


Abel = Table(
    abel,  # the generating function
    "Abel",  # name of the table
    ["A137452", "A061356", "A139526"],  # similar sequences in OEIS
    "A059297",  # OEIS-id of the inverse sequence
    r"is(k = 0)\ ? \ 0^n : \binom{n-1}{k-1} (-n)^{n - k}",  # TeX of the defining formula
)


@cache
def abelinv(n: int) -> list[int]:
    b = binomial(n)
    p = powers(n)
    return [b[k] * p[k] for k in range(n + 1)]


AbelInv = Table(
    abelinv,
    "AbelInv",
    ["A059297", "A059298"],
    "A137452",
    r"\binom{n}{k} k^{n - k}",
)


@cache
def _andre(n: int, k: int) -> int:
    if k == 0 or n == 0:
        return 1
    return -sum(Binomial(k, j) * _andre(n, j) for j in range(0, k, n))


@cache
def andre(n: int) -> list[int]:
    return [abs(_andre(k, n)) for k in range(n + 1)]


Andre = Table(
    andre,
    "Andre",
    ["A375555", "A181937"],
    "A000000",
    r"-\sum_{j = 0 \text{ by } n }^{k-1} \binom{k}{j} T_{n, j}",
)


@cache
def F(n: int) -> int:
    return factorial(n) ** 3 * ((n + 1) * (n + 1) * (n + 2))


@cache
def baxter(n: int) -> list[int]:
    if n == 0:
        return [1]
    return [0] + [(2 * F(n - 1)) // (F(k - 1) * F(n - k)) for k in range(1, n + 1)]


Baxter = Table(
    baxter,
    "Baxter",
    ["A359363", "A056939"],
    "A000000",
    "x Hyper([-1 - n, -n, 1 - n], [2, 3], -x)",
)


@cache
def bell(n: int) -> list[int]:
    if n == 0:
        return [1]
    prev_row = bell(n - 1)
    row = [prev_row[-1]] + prev_row
    for k in range(1, n + 1):
        row[k] += row[k - 1]
    return row


Bell = Table(
    bell,
    "Bell",
    ["A011971", "A011972", "A123346"],
    "",  # No inverse!
    r"\sum_{j=0}^{k} \binom{k}{j} Bell(n - k + j)",
)


@cache
def bessel(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = bessel(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] = row[k - 1] + (2 * (n - 1) - k) * row[k]
    return row


Bessel = Table(
    bessel,
    "Bessel",
    ["A132062", "A001497", "A001498", "A122850"],
    "A122848",
    r"2^{k - n} \binom{2n - 2k}{n - k} \binom{2n - k - 1}{k - 1} (n - k)!",
)


@cache
def besselinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    b = besselinv(n - 1)
    return [0] + [(2 * k - n + 1) * b[k] + b[k - 1] for k in range(1, n)] + [1]


BesselInv = Table(
    besselinv,  # the generating function
    "BesselInv",  # name of the table
    ["A122848", "A104556", "A096713"],  # similar sequences in OEIS
    "A132062",  # id of inverse sequence
    r"T(n,k)",  # TeX of defining formula
)


@cache
def bessel2(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 0]
    row = bessel2(n - 1) + [0]
    row[n] = 0 if n % 2 else row[n - 2]
    for k in range(2, n, 2):
        row[k] = (n * row[k]) // (n - k)
    return row


Bessel2 = Table(
    bessel2,
    "Bessel2",
    ["A359760", "A073278", "A066325", "A099174", "A111924", "A144299", "A104556"],
    "",
    r"is(k \text{ odd}) \, ? \, 0 : \binom{n}{k} \frac{k!}{2^{k/2} (k/2)!}",
)


@cache
def binarypell(n: int) -> list[int]:
    if n == 0:
        return [1]
    arow = binarypell(n - 1)
    row = arow + [1]
    for k in range(n - 1, 0, -1):
        row[k] = arow[k - 1] + 2 * arow[k]
    row[0] = 2 * arow[0]
    return row


BinaryPell = Table(
    binarypell,
    "BinaryPell",
    ["A038207"],
    "A065109",  # involutory
    r"\binom{n}{k} \, 2^{n-k}",
)


@cache
def binomial(n: int) -> list[int]:
    if n == 0:
        return [1]
    row: list[int] = [1] + binomial(n - 1)
    for k in range(1, n):
        row[k] += row[k + 1]
    return row


def invbinomial(n: int) -> list[int]:
    return [(-1) ** (n - k) * binomial(n)[k] for k in range(n + 1)]


Binomial = Table(
    binomial,
    "Binomial",
    [
        "A007318",
        "A074909",
        "A108086",
        "A117440",
        "A118433",
        "A130595",
        "A135278",
        "A154926",
    ],
    "A130595",
    r"n! \, / (k! \, (n - k)! )",
)
InvBinomial = Table(
    invbinomial,
    "InvBinomial",
    ["A130595"],
    "A000000",
    r"(-1)^{n-k} \, n! \, / (k! \, (n - k)! )",
)


@cache
def binomialinv(n: int) -> list[int]:
    return [(-1) ** (n - k) * binomial(n)[k] for k in range(n + 1)]


BinomialInv = Table(
    binomialinv,
    "BinomialInv",
    ["A130595"],
    "A007318",
    r"(-1)^{n-k} \, n! \, / (k! \, (n - k)! )",
)


@cache
def binomialbell(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    a = binomialbell(n - 1) + [1]
    s = sum(a) - 1
    for j in range(n - 1, 0, -1):
        a[j] = (a[j - 1] * n) // j
    a[0] = s
    return a


BinomialBell = Table(
    binomialbell,
    "BinomialBell",
    ["A056857", "A056860"],
    "",  # not invertible
    r"\binom{n}{k} \text{Bell}(n-k)",
)


@cache
def binomialcatalan(n: int) -> list[int]:
    if n == 0:
        return [1]
    a = binomialcatalan(n - 1) + [0]
    row = [0] * (n + 1)
    row[0] = 1
    row[1] = n
    for k in range(2, n + 1):
        row[k] = (a[k] * (n + k + 1) + a[k - 1] * (4 * k - 2)) // (n + 1)
    return row


BinomialCatalan = Table(
    binomialcatalan,
    "BinomialCatalan",
    ["A124644", "A098474"],
    "",  # not invertible
    r"\binom{n}{k} \text{Catalan}(n - k)",
)


@cache
def binomialpell(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [2, 2]
    arow = binomialpell(n - 1)
    row = arow + [n + 1]
    for k in range(1, n):
        row[k] = (arow[k - 1] * (n + 1)) // k
    row[0] = 2 * arow[0] + binomialpell(n - 2)[0]
    return row


BinomialPell = Table(
    binomialpell,
    "BinomialPell",
    ["A367211"],
    "",  # not invertible
    r"\binom{n+1}{k}\, \text{Pell}(n+1-k)",
)


@cache
def binomialdiffpell(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    arow = binomialdiffpell(n - 1)
    row = arow + [1]
    for k in range(1, n):
        row[k] = (arow[k - 1] * n) // k
    row[0] = 2 * arow[0] + binomialdiffpell(n - 2)[0]
    return row


BinomialDiffPell = Table(
    binomialdiffpell,
    "BinomialDiffPell",
    ["A367564"],
    "A000000",
    r"\frac{1}{2} \binom{n}{k} ((1-\sqrt{2})^{n-k} + (1+\sqrt{2})^{n-k})",
)


@cache
def catalan(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    pow = catalan(n - 1) + [0]
    row = pow.copy()
    for k in range(n - 1, 0, -1):
        row[k] = pow[k - 1] + 2 * pow[k] + pow[k + 1]
    row[n] = 1
    return row


Catalan = Table(
    catalan,
    "Catalan",
    ["A128899", "A039598"],
    "A128908",
    r"\sum_{i=1}^{n-k+1} \text{Catalan}(i) T_{k-1, n-i}",
)


@cache
def catalaninv(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = [0] * (n + 1)
    c0 = catalaninv(n - 2) + [0, 0]
    c1 = catalaninv(n - 1) + [0]
    for k in range(1, n + 1):
        row[k] = c1[k - 1] + 2 * c1[k] - c0[k]
    return row


CatalanInv = Table(
    catalaninv,  # the generating function
    "CatalanInv",  # name of the table
    ["A128908", "A053122", "A078812", "A285072"],  # similar sequences in OEIS
    "A128899",  # id of inverse sequence
    r"\binom{n+k-1}{2k-1}",  # TeX of defining formula
)


@cache
def catalanpaths(n: int) -> list[int]:
    if n == 0:
        return [1]

    def r(k: int) -> int:
        return catalanpaths(n - 1)[k] if k >= 0 and k < n else 0

    row = catalanpaths(n - 1) + [1]
    for k in range(0, n):
        row[k] = r(k - 1) + r(k + 1)
    return row


CatalanPaths = Table(
    catalanpaths,
    "CatalanPaths",
    ["A053121", "A052173", "A112554", "A322378"],
    "A049310",  # this is the Chebyshev S triangle
    r"is(k = 0)\ ? \ 0 : \frac{k+1}{n+1} \binom{n+1}{(n-k)/2}",
)


@cache
def centralcycle(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = centralcycle(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] = (n + k - 1) * (row[k] + row[k - 1])
    return row


CentralCycle = Table(
    centralcycle,
    "CentralCycle",
    ["A269940", "A111999", "A259456"],
    "",  # not ivertible
    r"\sum_{m=0}^k (-1)^{m+k} \binom{n+k}{n+m}\, {n + m \brack m}",
)


@cache
def centralfactorial(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [1] * (n + 1)
    for k in range(0, n):
        row[k + 1] = row[k] * (n * n - k * k)
    return row


CentralFactorial = Table(
    centralfactorial,  # the generating function
    "CentralFactorial",  # name of the table
    ["A370707"],  # similar sequences in OEIS
    "",  # no integer inverse triangle
    r"(-1)^k \prod_{j=0}^{k-1}\, (j - n)(j + n)",  # TeX of defining formula
)


@cache
def centralset(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = centralset(n - 1) + [1]
    for k in range(n - 1, 1, -1):
        row[k] = k**2 * row[k] + row[k - 1]
    return row


CentralSet = Table(
    centralset,
    "CentralSet",
    ["A269945", "A008957", "A036969"],
    "A269944",  # also "A204579"
    r"is(k = n)\ ? \ 1 : T(n-1, k-1) + k^2\ T(n-1, k)",
)


@cache
def centralsetinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = centralsetinv(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] = (n - 1) ** 2 * row[k] + row[k - 1]
    return row


CentralSetInv = Table(
    centralsetinv,
    "CentralSetInv",
    ["A269944", "A204579"],
    "A269945",
    r"%%",
)


@cache
def chains(n: int) -> list[int]:
    if n == 0:
        return [1]
    ch = chains(n - 1) + [0]
    row = ch.copy()
    row[0] = 2 * ch[0]
    row[n] = n * ch[n - 1]
    for k in range(n - 1, 0, -1):
        row[k] = k * ch[k - 1] + (k + 2) * ch[k]
    return row


Chains = Table(
    chains,
    "Chains",
    ["A038719"],
    "",
    r"\left({n+2 \brace k+2} -  {n+1 \brace k+2} \right)\, k!",
)


@cache
def charlier(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, -1]
    a = charlier(n - 1)
    b = [0] + charlier(n - 2)
    c = charlier(n - 1) + [(-1) ** n]
    for k in range(1, n):
        c[k] = a[k] - n * a[k - 1] - (n - 1) * b[k - 1]
    return c


Charlier = Table(
    charlier,
    "Charlier",
    ["A046716", "A094816"],
    "A000000",
    r"\sum_{j=0}^{k} (-1)^k \, \binom{n}{k-j}\,{j+n-k \brack n-k}",
)


@cache
def chebyshevs(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    rov = chebyshevs(n - 2)
    row = [0] + chebyshevs(n - 1)
    for k in range(0, n - 1):
        row[k] -= rov[k]
    return row


ChebyshevS = Table(
    chebyshevs,
    "ChebyshevS",
    ["A049310", "A053119", "A112552", "A168561"],
    "A053121",  # this is the Catalan Paths triangle
    r"\binom{(n+k)/2}{k} text{A369736}(n, k)",
)


@cache
def chebyshevt(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    rov = chebyshevt(n - 2)
    row = [0] + chebyshevt(n - 1)
    row[n] = 2 * row[n]
    for k in range(0, n - 1):
        row[k] = 2 * row[k] - rov[k]
    return row


ChebyshevT = Table(
    chebyshevt,
    "ChebyshevT",
    ["A053120", "A039991", "A081265"],
    "",  # not invertible
    r"%%",
)


@cache
def chebyshevu(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 2]
    rov = chebyshevu(n - 2)
    row = [0] + chebyshevu(n - 1)
    row[n] = 2 * row[n]
    for k in range(0, n - 1):
        row[k] = 2 * row[k] - rov[k]
    return row


ChebyshevU = Table(
    chebyshevu,
    "ChebyshevU",
    ["A053117", "A053118", "A115322"],
    "",  # not integer-invertible
    r"2^k \binom{(n+k)/2}{k} \text{A369736}(n, k)",
)


@cache
def _clp(n: int, k: int) -> int:
    if k < 0 or k > n:
        return 0
    if k == 0 or k == n:
        return 1
    return (
        2 * _clp(n - 1, k)
        + _clp(n - 1, k - 1)
        - 2 * _clp(n - 2, k - 1)
        + _clp(n - k - 1, k - 1)
        - _clp(n - k - 2, k)
    )


@cache
def compositionlp(n: int) -> list[int]:
    if n == 0:
        return [1]
    return [_clp(n - 1, k - 1) for k in range(n + 1)]


CompositionLP = Table(
    compositionlp,
    "CompositionLP",
    ["A048004"],
    "A000000",  # invertible, not in OEIS
    r"C_{LP}(n, k)",
)


@cache
def compositionacc(n: int) -> list[int]:
    return list(accumulate(compositionlp(n)))


CompositionAcc = Table(
    compositionacc,
    "CompositionAcc",
    ["A126198"],
    "",  # not integer-invertible
    r"\sum_{j=0}^k C_{LP}(n, j)",
)


@cache
def _compodist(n: int, k: int) -> int:
    if k < 0 or n < 0:
        return 0
    if k == 0:
        if n == 0:
            return 1
        else:
            return 0
    return _compodist(n - k, k) + k * _compodist(n - k, k - 1)


@cache
def compositiondist(n: int) -> list[int]:
    f = (sqrt(1 + 8 * n) - 1) // 2
    return [_compodist(n, k) if k <= f else 0 for k in range(n + 1)]


CompositionDist = Table(
    compositiondist, "CompositionDist", ["A072574", "A216652"], "", r"%%"
)


@cache
def ctree(n: int) -> list[int]:
    if n % 2 == 1:
        return [1] * (n + 1)
    return [1, 0] * (n // 2) + [1]


CTree = Table(
    ctree,
    "CTree",
    ["A106465", "A106470"],
    "A00000",
    r"is(n \text{ odd})\ ? \ 1 : (k + 1) \text{ mod } 2",
)


@cache
def delannoy(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    rov = delannoy(n - 2)
    row = delannoy(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] += row[k - 1] + rov[k - 1]
    return row


Delannoy = Table(
    delannoy,
    "Delannoy",
    ["A008288"],
    "A132372",
    r"\text{Hyper}([-k, k - n], [1], 2)",
)


@cache
def delannoyinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    d = delannoyinv(n - 1)
    row = [sum(d)] + d
    for k in range(n - 1, 0, -1):
        row[k] = row[k + 1] + d[k - 1] + d[k]
    return row


DelannoyInv = Table(
    delannoyinv,
    "DelannoyInv",
    ["A132372", "A103136", "A033878"],
    "A008288",
    r"%%",
)


@cache
def _distlattices(n: int, k: int) -> int:
    if k == 0 or n == 0:
        return 1
    s = [
        _distlattices(2 * j, k - 1) * _distlattices(n - 1 - 2 * j, k)
        for j in range(1 + (n - 1) // 2)
    ]
    return sum(s) + _distlattices(n, k - 1)


@cache
def distlattices(n: int) -> list[int]:
    return [_distlattices(n - k, k) for k in range(n + 1)]


DistLattices = Table(
    distlattices, "DistLattices", ["A050446", "A050447"], "A000000", r""
)


@cache
def divisibility(n: int) -> list[int]:
    if n == 0:
        return [1]
    L = [0 for _ in range(n + 1)]
    L[1] = L[n] = 1
    i = 1
    div = n
    while i < div:
        div, mod = divmod(n, i)
        if mod == 0:
            L[i] = L[div] = 1
        i += 1
    return L


Divisibility = Table(
    divisibility,
    "Divisibility",
    ["A113704", "A051731"],
    "A000000",
    r"[n=0 \text{ or } k \text{ divides } n]",
)


@cache
def doublepochhammer(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = doublepochhammer(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] = row[k - 1] + 2 * (n - 1) * row[k]
    return row


DoublePochhammer = Table(
    doublepochhammer,
    "DoublePochhammer",
    ["A039683"],
    "A00000",
    r"[x^k]\, x(x-2)(x-4)...(x-2n+2)",
)


@cache
def dyckpaths(n: int) -> list[int]:
    if n == 0:
        return [1]
    pow = dyckpaths(n - 1) + [0]
    row = pow.copy()
    row[0] += row[1]
    row[n] = 1
    for k in range(n - 1, 0, -1):
        row[k] = pow[k - 1] + 2 * pow[k] + pow[k + 1]
    return row


DyckPaths = Table(
    dyckpaths,
    "DyckPaths",
    ["A039599", "A050155"],
    "A000000",
    r"\binom{2n}{n - k} (2k + 1) / (n + k + 1)",
)


@cache
def dyckpathsinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    q = dyckpathsinv(n - 2) + [0]
    p = dyckpathsinv(n - 1) + [0]
    row = p.copy()
    row[n] = 1
    for k in range(n - 1, 0, -1):
        row[k] = p[k - 1] + 2 * p[k] - q[k]
    return row


DyckPathsInv = Table(
    dyckpathsinv,
    "DyckPathsInv",
    ["A085478", "A129818", "A123970"],
    "A039599",
    r"\binom{n+k}{2k}",
)


@cache
def entringer(n: int) -> list[int]:
    if n == 0:
        return [1]
    rowA = entringer(n - 1)
    row = [0] + entringer(n - 1)
    row[1] = row[n]
    for k in range(2, n + 1):
        row[k] = row[k - 1] + rowA[n - k]
    return row


Entringer = Table(
    entringer,
    "Entringer",
    ["A008281", "A008282", "A010094"],
    "",  # not invertible
    r"is(k=0) \ ? \ 0^n : T(n, k-1) + T(n-1, n-k)",
)


@cache
def _euclid(n: int, k: int) -> int:
    while k != 0:
        t = k
        k = n % k
        n = t
    return 1 if n == 1 else 0


@cache
def euclid(n: int) -> list[int]:
    return [_euclid(i, n) for i in range(n + 1)]


Euclid = Table(
    euclid, "Euclid", ["A217831"], "", r"is(k \text{ prime to } n ) \ ? \ 1 : 0"
)


@cache
def euler(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = euler(n - 1) + [1]
    for k in range(n, 0, -1):
        row[k] = (row[k - 1] * n) // (k)
    row[0] = -sum((-1) ** (j // 2) * row[j] for j in range(n, 0, -2))
    return row


Euler = Table(
    euler,
    "Euler",
    ["A363394", "A247453", "A109449"],
    "A000000",
    r"\binom{n}{k} 2^{n-k} \text{Euler}_{n-k}(1/2)",
)


@cache
def KnuthEulerian(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = KnuthEulerian(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] = (n - k) * row[k - 1] + (k + 1) * row[k]
    return row


@cache
def eulerian(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = eulerian(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] = (n - k + 1) * row[k - 1] + k * row[k]
    return row


Eulerian = Table(
    eulerian,
    "Eulerian",
    ["A173018", "A123125", "A008292"],
    "A055325",  # Inv of the A008292 version.
    r"\sum_{j=0}^{k} (-1)^{j} \binom{n+1}{j} (k+1-j)^{n}",
)


@cache
def eulerian2(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = eulerian2(n - 1) + [0]
    for k in range(n, 1, -1):
        row[k] = (2 * n - k) * row[k - 1] + k * row[k]
    return row


Eulerian2 = Table(
    eulerian2,
    "Eulerian2",
    ["A340556", "A201637", "A008517", "A112007", "A163936"],
    "A000000",
    r"%%",
)


@cache
def eulerianb(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = eulerianb(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] = (2 * (n - k) + 1) * row[k - 1] + (2 * k + 1) * row[k]
    return row


EulerianB = Table(eulerianb, "EulerianB", ["A060187", "A138076"], "A000000", r"%%")


@cache
def eulerianzigzag(n: int) -> list[int]:
    b = binomial(n + 1)
    return [
        sum((-1) ** j * b[j] * _distlattices(n, k - j) for j in range(k + 1))
        for k in range(n + 1)
    ]


@cache
def ezz(n: int) -> list[int]:
    n += 2
    b = binomial(n + 1)
    return [
        sum((-1) ** j * b[j] * _distlattices(n, k - j) for j in range(k + 1))
        for k in range(n - 1)
    ]


EulerianZigZag = Table(eulerianzigzag, "EulerianZigZag", ["A205497"], "", r"%%")


@cache
def eulersec(n: int) -> list[int]:
    if n == 0:
        return [1]
    b = binomial(n)
    row = [b[k] * eulersec(n - k)[0] if k > 0 else 0 for k in range(n + 1)]
    if n % 2 == 0:
        row[0] = -sum(row[2::2])
    return row


EulerSec = Table(
    eulersec,
    "EulerSec",
    ["A119879", "A081658", "A153641"],
    "A000000",
    r"\binom{n}{k}\, 2^{n-k}\ \text{Euler} (n-k, 1/2)",
)


def eulerS(n: int) -> int:
    return 0 if n % 2 == 1 else eulersec(n)[0]


@cache
def eulertan(n: int) -> list[int]:
    b = binomial(n)
    row = [b[k] * eulertan(n - k)[0] if k > 0 else 0 for k in range(n + 1)]
    if n % 2 == 1:
        row[0] = -sum(row[2::2]) + 1
    return row


EulerTan = Table(
    eulertan,
    "EulerTan",
    ["A162660", "A350972", "A155585", "A009006", "A000182"],
    "",
    r"[x^k]( -x^n + \sum_{k=0}^{n} \binom{n}{k} \text{Euler}(k) (x+1)^{n - k})",
)


def eulerT(n: int) -> int:
    return 0 if n % 2 == 0 else eulertan(n)[0]


@cache
def eytzingerorder(n: int) -> list[int]:
    row = [0] * (n + 1)

    def e_rec(k: int, i: int) -> int:
        if k <= n + 1:
            i = e_rec(2 * k, i)
            row[k - 1] = i
            i = e_rec(2 * k + 1, i + 1)
        return i

    e_rec(1, 0)
    return row


EytzingerOrder = Table(eytzingerorder, "EytzingerOrder", ["A375825"], "", r"%%")


@cache
def eytzingerperm(n: int) -> list[int]:
    t = n * (n + 1) // 2
    return [eytzingerorder(n)[k] + t for k in range(n + 1)]


EytzingerPerm = Table(eytzingerperm, "EytzingerPerm", ["A375469"], "", r"%%")


@cache
def fallingfactorial(n: int) -> list[int]:
    if n == 0:
        return [1]
    r = fallingfactorial(n - 1)
    row = [n * r[k] for k in range(-1, n)]
    row[0] = 1
    return row


FallingFactorial = Table(
    fallingfactorial,
    "FallingFactorial",
    ["A008279", "A068424", "A094587", "A173333", "A181511"],
    "",
    r"n! / (n - k)!",
)


@cache
def fibolucas(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 2]
    if n == 2:
        return [1, 2, 1]
    rowA = fibolucas(n - 2)
    row = fibolucas(n - 1) + [1 + n % 2]
    row[2] += 1
    for k in range(3, n):
        row[k] += rowA[k - 2]
    return row


FiboLucas = Table(
    fibolucas,
    "FiboLucas",
    ["A374439"],
    "",
    r"2^{k'} \, \binom{n - k' - (k - k') / 2}{(k - k') / 2} \text{ where } k' = k \text{ mod } 2",
)


@cache
def fibolucasinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [-2, 1]
    fli = fibolucasinv(n - 1)
    row = [1] * (n + 1)
    row[n - 1] = -2
    for k in range(n - 2, 0, -1):
        row[k] = fli[k - 1] - fli[k + 1]
    row[0] = -2 * fli[0] - fli[1]
    return row


FiboLucasInv = Table(fibolucasinv, "FiboLucasInv", ["A375025"], "A000000", r"%%")


@cache
def fibolucasrev(n: int) -> list[int]:
    if n == 0:
        return [1]
    return list(reversed(fibolucas(n)))


FiboLucasRev = Table(fibolucasrev, "FiboLucasRev", ["A124038"], "A000000", r"%%")


@cache
def fibonacci(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = fibonacci(n - 1) + [1]
    s = row[1]
    for k in range(n - 1, 0, -1):
        row[k] += row[k - 1]
    row[0] = s
    return row


Fibonacci = Table(
    fibonacci,
    "Fibonacci",
    ["A354267", "A105809", "A228074"],
    "A000000",
    r"T(n-1, k-1) + T(n-1, k)",
)


@cache
def fubini(n: int) -> list[int]:
    if n == 0:
        return [1]

    def r(k: int) -> int:
        return fubini(n - 1)[k] if k <= n - 1 else 0

    row = [0] + fubini(n - 1)
    for k in range(1, n + 1):
        row[k] = k * (r(k - 1) + r(k))
    return row


Fubini = Table(
    fubini,
    "Fubini",
    ["A131689", "A019538", "A090582", "A278075"],
    "",
    r"k! \ {n \brace k}",
)


@cache
def fusscatalan(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = fusscatalan(n - 1) + [fusscatalan(n - 1)[n - 1]]
    return list(accumulate(row))


FussCatalan = Table(
    fusscatalan,
    "FussCatalan",
    ["A355173", "A030237", "A054445"],
    "",
    r"is(k=0) \, ? \, 0^n : \frac{(n - k + 2) (n + k - 1)!}{(n + 1)! \, (k - 1)!}",
)


@cache
def gaussq2(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = gaussq2(n - 1)
    pow = [1] + gaussq2(n - 1)
    p = 2
    for k in range(1, n):
        pow[k] = row[k - 1] + p * row[k]
        p *= 2
    return pow


Gaussq2 = Table(
    gaussq2,
    "Gaussq2",
    ["A022166"],
    "A000000",
    r"\prod_{i=k+1}^{n} (2^i - 1) \ / \ \prod_{i=1}^{n-k} (2^i - 1)",
)


@cache
def genocchi(n: int) -> list[int]:
    if n == 0:
        return [1]
    row: list[int] = [0] + genocchi(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] += row[k + 1]
    for k in range(2, n + 2):
        row[k] += row[k - 1]
    return row[1:]


Genocchi = Table(genocchi, "Genocchi", ["A297703"], "", r"%%")


@cache
def harmonic(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = harmonic(n - 1) + [1]
    sav = row[1]
    for k in range(n - 1, 0, -1):
        row[k] = (n - 1) * row[k] + row[k - 1]
    row[1] += sav
    return row


Harmonic = Table(
    harmonic,
    "Harmonic",
    ["A358694", "A109822"],
    "A000000",
    r"T_{n - 1, k - 1} + (n - 1) T_{n - 1, k}; \ T_{n, 1} = n!",
)


@cache
def hermitee(n: int) -> list[int]:
    row = [0] * (n + 1)
    row[n] = 1
    for k in range(n - 2, -1, -2):
        row[k] = (row[k + 2] * (k + 2) * (k + 1)) // (n - k)
    return row


HermiteE = Table(
    hermitee,
    "HermiteE",
    ["A099174", "A066325", "A073278"],
    "A000000",
    r"is(n - k \text{ odd})\, ? \, 0 : \frac{n!}{k!} \, \frac{1}{(n-k)!!} )",
)


@cache
def hermiteh(n: int) -> list[int]:
    row = [0] * (n + 1)
    row[n] = 2**n
    for k in range(n - 2, -1, -2):
        row[k] = (row[k + 2] * (k + 2) * (k + 1)) // (2 * (n - k))
    return row


HermiteH = Table(
    hermiteh,
    "HermiteH",
    ["A060821"],
    "",
    r"is(n - k odd)\, ? \, 0 : (-1)^{(n-k)/2} \ \frac{n!}{k!} \ \frac{2^k}{((n-k)/2)!}",
)


@cache
def hyperharmonic(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = hyperharmonic(n - 1) + [1]
    for m in range(n - 1, 0, -1):
        row[m] = (n - m + 1) * row[m] + row[m - 1]
    row[0] *= n
    return row


HyperHarmonic = Table(
    hyperharmonic,
    "HyperHarmonic",
    ["A165675", "A093905", "A105954", "A165674"],
    "A000000",
    r"(n - k + 1)! \ \text{HyperHarmonic}(k, n - k)",
)


@cache
def jacobsthal(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    if n == 2:
        return [1, 2, 1]
    Jn1 = jacobsthal(n - 1)
    Jn2 = jacobsthal(n - 2) + [0]
    row = [1] * (n + 1)
    for k in range(1, n):
        row[k] = Jn1[k - 1] + Jn1[k] + 2 * Jn2[k]
    row[0] = Jn1[0] + 2 * Jn2[0]
    return row


Jacobsthal = Table(
    jacobsthal,
    "Jacobsthal",
    ["A322942"],
    "A000000",
    r"[x^k]\ ((x+1)\, \mathrm{J}(n-1, x) + 2\, \mathrm{J}(n-2, x))",
)


@cache
def labeledgraphs(n: int) -> list[int]:
    if n == 0:
        return [1]
    s = [
        2 ** (((k - n + 1) * (k - n)) // 2)
        * Binomial(n - 1, k - 1)
        * labeledgraphs(k)[k]
        for k in range(1, n)
    ]
    b = 2 ** (((n - 1) * n) // 2) - sum(s)
    return [0] + s + [b]


LabeledGraphs = Table(
    labeledgraphs,
    "LabeledGraphs",
    ["A360603"],
    "",
    r"2^{\binom{n-k}{2}} \binom{n-1}{k-1} \text{A001187}(k)",
)


@cache
def laguerre(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [0] + laguerre(n - 1)
    for k in range(0, n):
        row[k] += (n + k) * row[k + 1]
    return row


Laguerre = Table(
    laguerre,
    "Laguerre",
    ["A021009", "A021010", "A144084"],
    "A000000",
    r"\binom{n}{k}\, \frac{n!}{k!}",
)


@cache
def lah(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = lah(n - 1) + [1]
    row[0] = 0
    for k in range(n - 1, 0, -1):
        row[k] = row[k] * (n + k - 1) + row[k - 1]
    return row


Lah = Table(
    lah,
    "Lah",
    ["A271703", "A008297", "A066667", "A089231", "A105278", "A111596"],
    "A111596",
    r"\binom{n}{k} \text{FallingFactorial}(n-1, n-k)",
)


@cache
def t(n: int, k: int, m: int) -> int:
    if k < 0 or n < 0:
        return 0
    if k == 0:
        return n**k
    return m * t(n, k - 1, m) + t(n - 1, k, m + 1)


@cache
def lehmer(n: int) -> list[int]:
    return [t(k - 1, n - k, n - k) if n != k else 1 for k in range(n + 1)]


Lehmer = Table(
    lehmer,
    "Lehmer",
    ["A354794", "A039621"],
    "A000000",
    r"is(n = k)\ ? \ 1 : \sum_{j=0}^{k-1} (-1)^{j}(n-j-1)^{n-1}/(j! (k-1-j)!)",
)


@cache
def leibniz(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = leibniz(n - 1) + [n + 1]
    row[0] = row[n] = n + 1
    for k in range(1, n):
        row[k] = ((n - k + 1) * row[k - 1]) // k
    return row


Leibniz = Table(leibniz, "Leibniz", ["A003506"], "", r"(k+1) \, \binom{n+1}{k+1}")


@cache
def leibniztable(n: int) -> list[int]:
    if n == 0:
        return [0]
    L = leibniztable(n - 1)
    return [L[k] + k for k in range(n)] + [n]


LeibnizTable = Table(leibniztable, "LeibnizTable", ["A003991"], "", r"k\,(n - k + 1)")


@cache
def levin(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = levin(n - 1) + [1]
    row[0] = row[n] = (row[n - 1] * (4 * n - 2)) // n
    for k in range(1, n):
        row[k] = ((n - k + 1) * row[k - 1]) // k
    return row


Levin = Table(levin, "Levin", ["A356546"], "", r"\binom{2n}{n} \ \binom{n}{k}")


@cache
def lozanic(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [1] + lozanic(n - 1)
    for k in range(1, n):
        row[k] += row[k + 1]
    if n % 2 != 0:
        return row
    b = binomial(n // 2 - 1)
    for k in range(1, n, 2):
        row[k] -= b[(k - 1) // 2]
    return row


Lozanic = Table(
    lozanic,
    "Lozanic",
    ["A034851"],
    "A000000",
    r"\frac{1}{2} \left(\binom{n}{k}+\binom{n \text{ mod } 2}{k \text{ mod } 2} \binom{n \text{ div } 2}{k \text{ div } 2} \right)",
)


@cache
def lucas(n: int) -> list[int]:
    if n == 0:
        return [2]
    if n == 1:
        return [1, 2]
    row = lucas(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] += row[k - 1]
    return row


Lucas = Table(
    lucas, "Lucas", ["A029635", "A029653"], "", r"\binom{n}{k} + \binom{n-1}{k-1}"
)


@cache
def lucasinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    r = [1] + lucasinv(n - 1)
    for k in range(1, n):
        r[k] += 2 * r[k + 1]
    return r


LucasInv = Table(
    lucasinv,
    "LucasInv",
    ["A112857"],
    "A029635",
    r"\sum_{j=k^n} \binom{n}{j} \binom{j-1}{k-1}",
)


@cache
def lucaspoly(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 0]
    if n == 2:
        return [1, 1, 1]
    rowA = lucaspoly(n - 2)
    row = lucaspoly(n - 1) + [(n + 1) % 2]
    row[1] += 1
    for k in range(3, n):
        row[k] += rowA[k - 2]
    return row


LucasPoly = Table(
    lucaspoly, "LucasPoly", ["A374440"], "", r"T_{n - 1, k} + T_{n - 2, k - 2}"
)


@cache
def _moebius(n: int) -> int:
    if n == 1:
        return 1
    if n == 2:
        return -1
    return -sum(_moebius(k) for k, i in enumerate(divisibility(n)[: n - 1]) if i != 0)


@cache
def moebius(n: int) -> list[int]:
    if n == 0:
        return [1]
    r = [0 for _ in range(n + 1)]
    r[n] = 1
    for k in range(1, n):
        if n % k == 0:
            r[k] = _moebius(n // k)
    return r


Moebius = Table(
    moebius,
    "Moebius",
    ["A363914", "A054525"],
    "A000000",
    r"M^{-1}(n, k); M(n, k) = [k \le n \ \& \ k | n]",
)


@cache
def monotone(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [1 for _ in range(n + 1)]
    row[1] = n
    for k in range(1, n):
        row[k + 1] = (row[k] * (n + k)) // (k + 1)
    return row


Monotone = Table(
    monotone,
    "Monotone",
    ["A059481", "A027555"],
    "",  # not integer-invrtible
    r"\binom{n+k-1}{k}",
)


@cache
def motzkin(n: int) -> list[int]:
    if n == 0:
        return [1]
    r = motzkin(n - 1) + [0]
    row = motzkin(n - 1) + [1]
    for k in range(0, n):
        row[k] += r[k - 1] + r[k + 1]
    return row


Motzkin = Table(
    motzkin,
    "Motzkin",
    ["A064189", "A026300", "A009766", "A122896"],
    "A000000",
    r"\binom{n}{k} \text{Hyper}([(k-n)/2, (k-n+1)/2], [k+2], 4)",
)


@cache
def motzkininv(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [-1, 1]
    r2 = motzkininv(n - 2) + [0]
    r1 = motzkininv(n - 1) + [0]
    r = motzkininv(n - 1) + [1]
    for k in range(0, n):
        r[k] = r1[k - 1] - r2[k] - r1[k]
    return r


MotzkinInv = Table(
    motzkininv,
    "MotzkinInv",
    ["A104562", "A101950", "A344566"],
    "A064189",
    r"\binom{n}{k} \text{Hyper}([(k-n)/2, (k-n+1)/2], [k+2], 4)",
)


@cache
def motzkinpoly(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 0]
    h = 0 if n % 2 else (motzkinpoly(n - 2)[n - 2] * 2 * (n - 1)) // (n // 2 + 1)
    row = motzkinpoly(n - 1) + [h]
    for k in range(2, n, 2):
        row[k] = (n * row[k]) // (n - k)
    return row


MotzkinPoly = Table(
    motzkinpoly,
    "MotzkinPoly",
    ["A359364"],
    "",
    r"k \ \text{odd} \ ? \ 0 \ : \ \binom{n}{k} \text{Catalan}\left(\frac{k}{2}\right)",
)


@cache
def narayana(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = narayana(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] += ((2 * n - k) * row[k - 1]) // k
    return row


Narayana = Table(
    narayana,
    "Narayana",
    ["A090181", "A001263", "A131198"],
    "A103364",
    r"\binom{n}{n-k} \binom{n-1}{n-k} \frac{1}{n-k+1}",
)


@cache
def narayana2(n: int) -> list[int]:
    if n < 3:
        return ([1], [0, 1], [0, 1, 1])[n]
    a = narayana2(n - 2) + [0, 0]
    b = narayana2(n - 1) + [1]
    for k in range(n - 1, 1, -1):
        b[k] = (
            (b[k] + b[k - 1]) * (2 * n - 3) - (a[k] - 2 * a[k - 1] + a[k - 2]) * (n - 3)
        ) // n
    return b


Narayana2 = Table(
    narayana2,
    "Narayana2",
    ["A352687"],
    "A000000",
    r"%%",
)


@cache
def naturals(n: int) -> list[int]:
    R = range((n * (n + 1)) // 2, ((n + 1) * (n + 2)) // 2)
    return [i + 1 for i in R]


Naturals = Table(
    naturals,
    "Naturals",
    ["A000027", "A001477"],
    "",  # not integer-invertible
    r"n+1 + (k+n) (k+n+1)/2",
)


@cache
def nicomachus(n: int) -> list[int]:
    if n == 0:
        return [1]
    prev_row = nicomachus(n - 1)
    row = prev_row + [3 * prev_row[-1]]
    for k in range(0, n):
        row[k] *= 2
    return row


Nicomachus = Table(
    nicomachus,
    "Nicomachus",
    ["A036561", "A081954", "A175840"],
    "",
    r"2^{n - k}\, 3^{k}",
)


@cache
def nimsum(n: int) -> list[int]:
    return [k ^ (n - k) for k in range(n + 1)]


NimSum = Table(nimsum, "NimSum", ["A003987"], "", r"k \ \text{XOR} \ (n - k)")


@cache
def one(n: int) -> list[int]:
    if n == 0:
        return [1]
    return one(n - 1) + [1]


One = Table(one, "One", ["A000012", "A008836", "A014077"], "A167374", r"1")


@cache
def ordinals(n: int) -> list[int]:
    if n == 0:
        return [0]
    return ordinals(n - 1) + [n]


Ordinals = Table(
    ordinals, "Ordinals", ["A002262", "A002260", "A004736", "A025581"], "", r"k"
)


@cache
def orderedcycle(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = orderedcycle(n - 1) + [0]
    row[n] = row[n] * n
    for k in range(n, 0, -1):
        row[k] = (n - 1) * row[k] + k * row[k - 1]
    return row


OrderedCycle = Table(
    orderedcycle,
    "OrderedCycle",
    ["A225479", "A048594", "A075181"],
    "",  # not invertible
    r"k! {n \brack k}",
)


@cache
def A(n: int, k: int) -> int:
    if n == 0:
        return int(k == 0)
    if k > n:
        n, k = k, n
    b = binomial(k + 1)
    return k * A(n - 1, k) + sum(b[j + 1] * A(n - 1, k - j) for j in range(1, k + 1))


@cache
def parades(n: int) -> list[int]:
    return [A(n - k, k) for k in range(n + 1)]


Parades = Table(
    parades,
    "Parades",
    ["A371761", "A272644"],
    "",
    r"\sum_{j=0}^{k} \, {n - k \brace j} \, {k \brace j} \, (j!)^2",
)


@cache
def part(n: int, k: int) -> int:
    if k < 0 or n < 0:
        return 0
    if k == 0:
        return 1 if n == 0 else 0
    return part(n - 1, k - 1) + part(n - k, k)


@cache
def partition(n: int) -> list[int]:
    return [part(n, k) for k in range(n + 1)]


Partition = Table(
    partition,
    "Partition",
    ["A072233", "A008284", "A058398"],
    "A000000",
    r"T_{n - 1, k - 1} + T_{n - k, k}",
)


@cache
def partitionacc(n: int) -> list[int]:
    return list(accumulate(partition(n)))


PartitionAcc = Table(partitionacc, "PartitionAcc", ["A026820", "A058400"], "", r"%%")


@cache
def _partdist(n: int, k: int) -> int:
    if k < 1 or n < k:
        return 0
    if n == 1:
        return 1
    return _partdist(n - k, k) + _partdist(n - k, k - 1)


@cache
def partitiondist(n: int) -> list[int]:
    if n == 0:
        return [1]
    f = (sqrt(1 + 8 * n) - 1) // 2
    return [_partdist(n, k) if k <= f else 0 for k in range(n + 1)]


PartitionDist = Table(partitiondist, "PartitionDist", ["A008289"], "", r"%%")


@cache
def _partdistsize(n: int, k: int, r: int) -> int:
    if n == 0:
        return 1 if k == 0 else 0
    if k == 0 or r == 0:
        return 0
    if k > n // 2 + 1:
        return 0
    s = [_partdistsize(n - r * j, k - 1, r - 1) for j in range(1, n // r + 1)]
    return sum(s) + _partdistsize(n, k, r - 1)


@cache
def partitiondistsize(n: int) -> list[int]:
    f = (sqrt(1 + 8 * n) - 1) // 2
    return [_partdistsize(n, k, n) if k <= f else 0 for k in range(n + 1)]


PartitionDistSize = Table(
    partitiondistsize, "PartitionDistSize", ["A365676", "A116608", "A060177"], "", r"%%"
)


@cache
def pascal(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [1] + pascal(n - 1)
    for k in range(1, n):
        row[k] += row[k + 1]
    return row


Pascal = Table(
    pascal,
    "Pascal",
    [
        "A007318",
        "A074909",
        "A108086",
        "A117440",
        "A118433",
        "A130595",
        "A135278",
        "A154926",
    ],
    "A000000",
    r"\binom{n}{k}",
)


@cache
def divisors(n: int) -> list[int]:
    return [d for d in range(n, 0, -1) if n % d == 0]


@cache
def _h(n: int, k: int) -> int:
    return sum(d * _T(d, k) for d in divisors(n))


@cache
def _T(n: int, k: int) -> int:
    if n == 1:
        return int(k > 0)
    return sum(_T(i, k) * _h(n - i, k - 1) for i in range(1, n)) // (n - 1)


@cache
def polyatreeacc(n: int) -> list[int]:
    if n > 200:
        # raise ValueError("n is too large for this function.")
        print(f"ValueError: n = {n} is too large for function polyatreeacc.")
        return []
    return [_T(n + 1, k + 1) for k in range(n + 1)]


PolyaTreeAcc = Table(polyatreeacc, "PolyaTreeAcc", ["A375467"], "", r"%%")


@cache
def polyatree(n: int) -> list[int]:
    p = polyatreeacc(n)
    return [int(n < 1)] + [p[k] - p[k - 1] for k in range(1, n + 1)]


PolyaTree = Table(
    polyatree,
    "PolyaTree",
    ["A034781"],
    "",
    r"A375467(n, k) - A375467(n, k - 1)",
)


@cache
def polygonal(n: int) -> list[int]:
    if n == 0:
        return [0]
    if n == 1:
        return [0, 1]
    rov = polygonal(n - 2)
    row = polygonal(n - 1) + [n]
    row[n - 1] += row[n - 2]
    for k in range(2, n - 1):
        row[k] += row[k] - rov[k]
    return row


Polygonal = Table(
    polygonal,
    "Polygonal",
    ["A139600", "A057145", "A134394", "A139601"],
    "",
    r"k + \frac{1}{2}\, n\, k\, (k-1)",
)


@cache
def powlaguerre(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = powlaguerre(n - 1) + [1]
    row[0] = row[n] = row[0] * n
    for k in range(1, n):
        row[k] = ((n - k + 1) * row[k - 1]) // k
    return row


PowLaguerre = Table(
    powlaguerre, "PowLaguerre", ["A196347", "A021012"], "", r"n! \binom{n}{k}"
)


@cache
def powers(n: int) -> list[int]:
    if n == 0:
        return [1]
    lrow = powers(n - 1)
    return [k * lrow[k] for k in range(n)] + [1]


Powers = Table(
    powers,  # the generating function
    "Powers",  # name of the table
    ["A004248", "A009998", "A051129"],  # similar sequences in OEIS
    "A000000",  # inverse triangle exists, but not in OEIS
    r"k^{n - k}",  # TeX of defining formula
)


@cache
def rencontres(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = [(n - 1) * (rencontres(n - 1)[0] + rencontres(n - 2)[0])] + rencontres(n - 1)
    for k in range(1, n - 1):
        row[k] = (n * row[k]) // k
    return row


Rencontres = Table(
    rencontres,
    "Rencontres",
    ["A008290", "A098825"],
    "A055137",
    r"\binom{n}{k} derangements(n - k)",
)


@cache
def rencontresinv(n: int) -> list[int]:
    if n == 0:
        return [1]
    return [(n - k - 1) * binomial(n)[k] for k in range(n)] + [1]


RencontresInv = Table(
    rencontresinv,
    "RencontresInv",
    ["A055137"],
    "A008290",
    r"\binom{n}{k} (n-k-1)",
)


@cache
def risingfactorial(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [1 for _ in range(n + 1)]
    row[1] = n
    for k in range(1, n):
        row[k + 1] = row[k] * (n + k)
    return row


RisingFactorial = Table(
    risingfactorial,
    "RisingFactorial",
    ["A124320"],
    "",
    r"k! \binom{n+k-1}{k}",
)


@cache
def rootedtree(n: int) -> list[int]:
    p = polyatreeacc(n)
    return [0] + [p[k + 1] - p[k] for k in range(n)]


RootedTree = Table(
    rootedtree,
    "RootedTree",
    ["A034781"],
    "",
    r"A375467(n, k) - A375467(n, k - 1)",
)


@cache
def schroeder(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = schroeder(n - 1) + [1]
    for k in range(n - 1, 0, -1):
        row[k] += row[k - 1] + row[k + 1]
    return row


Schroeder = Table(
    schroeder,
    "Schroeder",
    ["A122538", "A033877", "A080245", "A080247", "A106579"],
    "A000000",
    r"is(k = 0)\ ? \ 0^{n} : T(n-1,k-1)+T(n-1,k)+T(n,k+1)",
)


@cache
def schroederl(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    arow = schroederl(n - 1) + [0]
    row = schroederl(n - 1) + [1]
    row[0] = row[0] + 2 * row[1]
    for k in range(1, n):
        row[k] = arow[k - 1] + 3 * arow[k] + 2 * arow[k + 1]
    return row


SchroederL = Table(schroederl, "SchroederL", ["A172094"], "A000000", r"%%")


@cache
def schroederp(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = schroederp(n - 1) + [1]
    for k in range(n, 0, -1):
        row[k] = (row[k - 1] * (2 * n - k)) // k
    row[0] = (row[0] * (4 * n - 2)) // n
    return row


SchroederP = Table(
    schroederp,
    "SchroederP",
    ["A104684", "A063007"],
    "A000000",
    r"\binom{n}{k} \binom{2n - k}{n}",
)


def seidel(n: int) -> list[int]:
    return entringer(n) if n % 2 else entringer(n)[::-1]


Seidel = Table(seidel, "Seidel", ["A008280", "A108040", "A236935", "A239005"], "", r"")


@cache
def sierpinski(n: int) -> list[int]:
    return [int(not ~n & k) for k in range(n + 1)]


Sierpinski = Table(
    sierpinski,
    "Sierpinski",
    ["A047999", "A090971", "A114700", "A143200", "A166282"],
    "A000000",
    r"\binom{n}{k} \text{ mod } 2",
)


@cache
def stirlingcycle(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [0] + stirlingcycle(n - 1)
    for k in range(1, n):
        row[k] = row[k] + (n - 1) * row[k + 1]
    return row


StirlingCycle = Table(
    stirlingcycle,
    "StirlingCycle",
    ["A132393", "A008275", "A008276", "A048994", "A054654", "A094638", "A130534"],
    "A000000",
    r"{n \brack k}",
)


@cache
def stirlingcycle2(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 0]
    rov = stirlingcycle2(n - 2)
    row = stirlingcycle2(n - 1) + [0]
    for k in range(1, n // 2 + 1):
        row[k] = (n - 1) * (rov[k - 1] + row[k])
    return row


StirlingCycle2 = Table(
    stirlingcycle2,
    "StirlingCycle2",
    ["A358622", "A008306", "A106828"],
    "",
    r"n! [z^k][t^n] (\exp(t) (1 - t))^{-z}",
)


@cache
def stirlingcycleb(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = stirlingcycleb(n - 1) + [1]
    m = 2 * n - 1
    for k in range(n - 1, 0, -1):
        row[k] = m * row[k] + row[k - 1]
    row[0] *= m
    return row


StirlingCycleB = Table(
    stirlingcycleb,
    "StirlingCycleB",
    ["A028338", "A039757", "A039758", "A109692"],
    "A000000",
    r"\sum_{i=k}^{n} (-2)^{n-i} \binom{i}{k} {n \brack i}",
)


@cache
def stirlingset(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = [0] + stirlingset(n - 1)
    for k in range(1, n):
        row[k] = row[k] + k * row[k + 1]
    return row


StirlingSet = Table(
    stirlingset,
    "StirlingSet",
    [
        "A048993",
        "A008277",
        "A008278",
        "A080417",
        "A106800",
        "A151511",
        "A151512",
        "A154959",
        "A213735",
    ],
    "A132393",
    r"{n \brace k}",
)


@cache
def stirlingset2(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 0]
    rov = stirlingset2(n - 2)
    row = stirlingset2(n - 1) + [0]
    for k in range(1, n // 2 + 1):
        row[k] = (n - 1) * rov[k - 1] + k * row[k]
    return row


StirlingSet2 = Table(
    stirlingset2,
    "StirlingSet2",
    ["A358623", "A008299", "A137375"],
    "",
    r"\sum_{j=0}^{k} (-1)^{k-j} \binom{n}{k-j} {n-k+j \brace j}",
)


@cache
def stirlingsetb(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [1, 1]
    pow = stirlingsetb(n - 1)
    row = stirlingsetb(n - 1) + [1]
    row[0] += 2 * row[1]
    for k in range(1, n - 1):
        row[k] = 2 * (k + 1) * pow[k + 1] + (2 * k + 1) * pow[k] + pow[k - 1]
    row[n - 1] = (2 * n - 1) * pow[n - 1] + pow[n - 2]
    return row


StirlingSetB = Table(
    stirlingsetb,
    "StirlingSetB",
    ["A154602"],
    "A000000",
    r"\sum_{j=k}^{n} 2^{n-j} \binom{j}{k} {n \brace j}",
)


@cache
def sylvester(n: int) -> list[int]:
    def s(n: int, k: int) -> int:
        return sum(
            Binomial(n, k - j) * StirlingCycle(n - k + j, j) for j in range(k + 1)
        )

    return [s(n, k) for k in range(n + 1)]


Sylvester = Table(
    sylvester,
    "Sylvester",
    ["A341101"],
    "",
    r"\sum_{j=0}^{k} (-1)^{n-k} \binom{n}{k-j} {n - k + j \brack j}",
)


@cache
def ternarytree(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = ternarytree(n - 1) + [ternarytree(n - 1)[n - 1]]
    return list(accumulate(accumulate(row)))


TernaryTree = Table(
    ternarytree,
    "TernaryTrees",
    ["A355172"],
    "",
    r"is(k=0)\, ?\, 0^n : \frac{(2n-2k+3) \, (2n+k-1)!}{(2n+1)! \, (k-1)!}",
)


@cache
def wardset(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = wardset(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] = k * row[k] + (n + k - 1) * row[k - 1]
    return row


WardSet = Table(
    wardset,
    "WardSet",
    ["A269939", "A134991"],
    "",
    r"\sum_{m=0}^{k} (-1)^{m + k} \binom{n+k}{n+m} { n + m \brace m}",
)


@cache
def wardcycle(n: int) -> list[int]:
    if n == 0:
        return [1]
    if n == 1:
        return [0, 1]
    row = wardcycle(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] = (n + k - 1) * (row[k - 1] + row[k])
    return row


WardCycle = Table(
    wardcycle,
    "WardCycle",
    ["A269940", "A111999", "A259456"],
    "",
    r"\sum_{m=0}^{k} (-1)^{m+k} \binom{n+k}{n+m} { n + m \brack m}",
)


@cache
def worpitzky(n: int) -> list[int]:
    if n == 0:
        return [1]
    row = worpitzky(n - 1) + [0]
    for k in range(n, 0, -1):
        row[k] = k * row[k - 1] + (k + 1) * row[k]
    return row


Worpitzky = Table(
    worpitzky,
    "Worpitzky",
    ["A028246", "A053440", "A075263", "A130850", "A163626"],
    "",
    r"\sum_{j=0}^{n} \text{Eulerian}(n, j) \binom{n-j}{n-k}",
)


def bell_num(n: int) -> int:
    if n == 0:
        return 1
    return bell(n - 1)[-1]


def Bernoulli(n: int) -> Fraction:
    if n < 2:
        return Fraction(1, n + 1)
    if n % 2 == 1:
        return Fraction(0, 1)
    g = genocchi(n // 2 - 1)[-1]
    f = Fraction(g, 2 ** (n + 1) - 2)
    return -f if n % 4 == 0 else f


def euler_num(n: int) -> int:
    return euler(n)[0]


@cache
def eulerphi(n: int) -> int:
    return sum(k * moebius(n)[k] for k in range(n + 1))


def motzkin_num(n: int) -> int:
    return sum(motzkinpoly(n))


def partlist_num(n: int) -> int:
    return sum(lah(n))


def part_num(n: int) -> int:
    return sum(partition(n))


def riordan_num(n: int) -> int:
    return sum((-1) ** (n - k) * BinomialCatalan(n, k) for k in range(n + 1))


TablesList: list[Table] = [
    Abel,
    AbelInv,
    Andre,
    Baxter,
    Bell,
    Bessel,
    BesselInv,
    Bessel2,
    BinaryPell,
    Binomial,
    BinomialInv,
    BinomialBell,
    BinomialCatalan,
    BinomialPell,
    BinomialDiffPell,
    Catalan,
    CatalanInv,
    CatalanPaths,
    CentralCycle,
    CentralFactorial,
    CentralSet,
    CentralSetInv,
    Chains,
    Charlier,
    ChebyshevS,
    ChebyshevT,
    ChebyshevU,
    CompositionLP,
    CompositionAcc,
    CompositionDist,
    CTree,
    Delannoy,
    DelannoyInv,
    DistLattices,
    Divisibility,
    DoublePochhammer,
    DyckPaths,
    DyckPathsInv,
    Entringer,
    Euclid,
    Euler,
    Eulerian,
    Eulerian2,
    EulerianB,
    EulerianZigZag,
    EulerSec,
    EulerTan,
    EytzingerOrder,
    EytzingerPerm,
    FallingFactorial,
    FiboLucas,
    FiboLucasInv,
    FiboLucasRev,
    Fibonacci,
    Fubini,
    FussCatalan,
    Gaussq2,
    Genocchi,
    Harmonic,
    HermiteE,
    HermiteH,
    HyperHarmonic,
    Jacobsthal,
    LabeledGraphs,
    Laguerre,
    Lah,
    Lehmer,
    Leibniz,
    LeibnizTable,
    Levin,
    Lozanic,
    Lucas,
    LucasInv,
    LucasPoly,
    Moebius,
    Monotone,
    Motzkin,
    MotzkinInv,
    MotzkinPoly,
    Narayana,
    Narayana2,
    Naturals,
    Nicomachus,
    NimSum,
    One,
    Ordinals,
    OrderedCycle,
    Parades,
    Partition,
    PartitionAcc,
    PartitionDist,
    PartitionDistSize,
    Pascal,
    PolyaTreeAcc,
    PolyaTree,
    Polygonal,
    PowLaguerre,
    Powers,
    Rencontres,
    RencontresInv,
    RisingFactorial,
    RootedTree,
    Schroeder,
    SchroederL,
    SchroederP,
    Seidel,
    Sierpinski,
    StirlingCycle,
    StirlingCycle2,
    StirlingCycleB,
    StirlingSet,
    StirlingSet2,
    StirlingSetB,
    Sylvester,
    TernaryTree,
    WardSet,
    WardCycle,
    Worpitzky,
]
# TablesListPreview()
